<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Stay  hungry，Stay  foolish!">

    <title>二叉树与常用算法 - Page</title>

    <link rel="canonical" href="http://localhost:4000/blog/DataStrucure-Algorithm.html">

    <!-- Icons -->
  <link rel="shortcut icon" href="img/favicon.ico">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>


<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Page</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/">Home</a>
                </li>
                
                <li>
                    <a href="/About.html">About</a>
                </li>
                
                <li>
                    <a href="/tags.html">Tags</a>
                </li>
                
                <li>
                    <a href="/photos/">Photos</a>
                </li>
                

            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/fantasy.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="Tags">
                        
                        <a class="tag" href="/Tags/#Algorithm" title="Algorithm">Algorithm</a>
                        
                        <a class="tag" href="/Tags/#Binary Tree" title="Binary Tree">Binary Tree</a>
                        
                    </div>
                    <h1>二叉树与常用算法</h1>
                    
                    <span class="meta">Posted by Jack on February 24, 2016</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container">

                <h1 id="1常用算法">1、常用算法</h1>

<ul>
  <li>插入排序（直接插入排序、希尔排序）</li>
  <li>交换排序（冒泡排序、快速排序）</li>
  <li>选择排序（直接选择排序、堆排序）</li>
  <li>归并排序</li>
  <li>分配排序（基数排序）</li>
</ul>

<p>所需辅助空间最多：归并排序 
所需辅助空间最少：堆排序 
平均速度最快：快速排序 
不稳定：快速排序，希尔排序，堆排序。</p>

<h2 id="a-直接插入排序">a 直接插入排序</h2>
<p>基本思想：在要排序的一组数中，假设前面(n-1)[n&gt;=2] 个数已经是排好顺序的，现在要把第n 个数插到前面的有序数中，使得这 n个数 也是排好顺序的。如此反复循环，直到全部排好顺序。 
排序时间取决于输入元素的初始顺序，对于部分有序的排序使用时间较短。</p>

<pre><code class="language-Java">void insertSort(){  
	int a[] = {45,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51};   
	for(int i = 0; i &lt; a.length; i++ ) {
		temp = a[i];
		for(int j = i-1；j&gt; 0 &amp;&amp; temp &lt; a[j];j--) {
			a[j+1] = a[j];
		}
		a[j+1] = temp;
	}
}
</code></pre>

<h2 id="b-希尔排序最小增量排序">b 希尔排序（最小增量排序）</h2>
<p>基本思想：算法先将要排序的一组数按某个增量 d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.
对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到 1 时，进行直接插入排序后，排序完成。 
中等大小的数组运行时间是可以接受的，代码量较少，并且不需要额外的空间。</p>

<pre><code class="language-Java">	shellSort(){   
		int a[]={1,54,6,3,78,34,12,45,56,100};   
		double d1=a.length;   
		int temp=0;   
		while(true){   
			d1= Math.ceil(d1/2);   
			int d=(int) d1;
			for(int x=0;x&lt; d;x++){
				for(int i=x+d;i&lt; a.length;i+=d){
					int j=i-d;
					temp=a[i];
					for(;j&gt;=0&amp;&amp;temp&lt; a[j];j-=d){
						a[j+d]=a[j];   
	              	}
	              	a[j+d]=temp;
	            }
	        }
	        if(d==1){
	        	break;
	        }
	    }
	}
</code></pre>

<h2 id="c-简单选择排序">c 简单选择排序</h2>
<p>基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换； 然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。 
由有序数组或者数字相同或者随机的数组使用排序时间一样长：**缺点**
数据交换最少：每次交换都会改变两个数组的值，使用N次交换。</p>

<pre><code class="language-Java">	selectSort(){
		int a[]={1,54,6,3,78,34,12,45};
		int position=0;
		for(int i=0;i&lt; a.length;i++){
			int j=i+1;
			position=i;
			int temp=a[i];
			for(;j&lt; a.length;j++){
				if(a[j]&lt; temp){
					temp=a[j];
					position=j;
				}
			}
			a[position]=a[i];a[i]=temp;
		}
	}   
</code></pre>

<h2 id="d-堆排序">d 堆排序</h2>
<p>基本思想：堆排序是一种树形选择排序，是对直接选择排序的有效改进。 堆的定义如下：具有n个元素的序列（h1,h2,...,hn),当且仅当满足（hi&gt;=h2i,hi&gt;=2i+1）或（hi&lt;=h2i,hi&lt;=2i+1）(i=1,2,...,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有 n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</p>

<pre><code class="language-Java">	void heapSort(int[] a){   
		int arrayLength=a.length;   
		for(int i=0;i&lt; arrayLength-1;i++){   
			buildMaxHeap(a,arrayLength-1-i);   
			swap(a,0,arrayLength-1-i);   
			System.out.println(Arrays.toString(a));   
		}   
	}   

	private  void swap(int[] data, int i, int j) {   
		int tmp=data[i];   
		data[i]=data[j];   
		data[j]=tmp;   
	}   
    
    //对data 数组从0到lastIndex 建大顶堆   
	private void buildMaxHeap(int[] data, int lastIndex) {   
		//从lastIndex 处节点（最后一个节点）的父节点开始   
		for(int i=(lastIndex-1)/2;i&gt;=0;i--){   
			//k 保存正在判断的节点   
			int k=i;   
			//如果当前k节点的子节点存在  
			while(k*2+1&lt;=lastIndex){   
				//k 节点的左子节点的索引  
				int biggerIndex=2*k+1;   
				//如果biggerIndex 小于lastIndex，即biggerIndex+1 代表的k 节点的右子节点存在   
				if(biggerIndex&lt;lastIndex){  
					//若果右子节点的值较大   
					if(data[biggerIndex]&lt;data[biggerIndex+1]){   
						//biggerIndex 总是记录较大子节点的索引   
						biggerIndex++;   
					}   
				 }   
				//如果k节点的值小于其较大的子节点的值   
				if(data[k]&lt;data[biggerIndex]){   
					//交换他们   
					swap(data,k,biggerIndex);    
					//将biggerIndex 赋予k，开始while 循环的下一次循环，重新保证k节点的值大于其左右子节点的值   
					k=biggerIndex;   
				 }else{   
					break;   
				 }   
			}   
		}   
	}   
</code></pre>

<h2 id="e-冒泡排序">e 冒泡排序</h2>
<p>基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>

<pre><code class="language-Java">	bubbleSort(){  
		int a[]={49,38,65,97,76,13,64,5,4,62,99,98,54,5,35,25,53,51};   
		int temp=0;   
		for(int i=0;i&lt; a.length-1;i++){   
			for(int j=0;j&lt; a.length-1-i;j++){   
				if(a[j]&gt;a[j+1]){   
					temp=a[j];   
					a[j]=a[j+1];   
					a[j+1]=temp;   
				}   
			}
		}   
	}   
</code></pre>

<h2 id="f-快速排序">f 快速排序</h2>
<p>基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。</p>

<pre><code class="language-Java">	quickSort {        
		int a[]={49,38,65,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51};   
		public quickSort(){   
			quick(a);   
			for(int i=0;i&lt; a.length;i++){   
				System.out.println(a[i]);   
			}   
		}	 

		public int getMiddle(int[] list, int low, int high) {     
			int tmp =list[low];    //数组的第一个作为中轴     
			while (low &lt; high){     
				while (low &lt; high&amp;&amp; list[high] &gt;= tmp) {     
					high--;     
				}     

				list[low] =list[high];   //比中轴小的记录移到低端     
				while (low &lt; high&amp;&amp; list[low] &lt;= tmp) {     
					low++;     
				}     

				list[high] =list[low];   //比中轴大的记录移到高端     
			}     
			list[low] = tmp;              //中轴记录到尾     
			return low;                   //返回中轴的位置     
		}    

		public void _quickSort(int[] list, int low, int high) {     
			if (low &lt; high){     
				int middle =getMiddle(list, low, high);  //将list 数组进行一分为二     
				_quickSort(list, low, middle - 1);       //对低字表进行递归排序     
				_quickSort(list,middle + 1, high);       //对高字表进行递归排序     
			}     
		}   

		public void quick(int[] a2) {     
			if (a2.length &gt; 0) {    //查看数组是否为空     
				_quickSort(a2,0, a2.length - 1);     
			}     
		}
	}    
  
</code></pre>

<h2 id="g-归并排序">g 归并排序</h2>
<p>基本排序：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。
保证任意长度N的数组排序需要的时间和NlogN成正比。
**缺点** 需要的额外空间和N成正比。
sort()作用在于安排多次merge（）方法调用正确顺序。</p>

<pre><code class="language-Java">	mergingSort {   
		int a[]={49,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51};   
	 
		public mergingSort(){   
			sort(a,0,a.length-1);   
			for(int i=0;i&lt;a.length;i++)   
				System.out.println(a[i]);   
		}   

		public void sort(int[] data, int left, int right) {      
			if(left&lt;right){   
				//找出中间索引   
				int center=(left+right)/2;   
				//对左边数组进行递归    
				sort(data,left,center);   
				//对右边数组进行递归   
				sort(data,center+1,right);   
				//合并   
				merge(data,left,center,right);          
			}   

		}   

		public void merge(int[] data, int left, int center, int right) {   
			int[] tmpArr=newint[data.length];   
			int mid=center+1;   
			//third 记录中间数组的索引   
			int third=left;   
			int tmp=left;   
			while(left&lt;=center&amp;&amp;mid&lt;=right){   
				//从两个数组中取出最小的放入中间数组   
				if(data[left]&lt;=data[mid]){   
					tmpArr[third++]=data[left++];   
				}else{   
					tmpArr[third++]=data[mid++];   
				}   
			}   

			//剩余部分依次放入中间数组   
			while(mid&lt;=right){   
				tmpArr[third++]=data[mid++];   
			}   

			while(left&lt;=center){   
				tmpArr[third++]=data[left++];   
			}   

			//将中间数组中的内容复制回原数组   
			while(tmp&lt;=right){   
				data[tmp]=tmpArr[tmp++];   
			}   
			System.out.println(Arrays.toString(data));   
		}   
	}   
</code></pre>

<h2 id="h-基数排序">h 基数排序</h2>
<p>基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。 </p>

<pre><code class="language-Java">	radixSort {   
		int a[]={49,39,98,54,101,56,17,18,23,34,15,35,25,53,51};   

		public radixSort(){   
			sort(a);   
			for(inti=0;i&lt;a.length;i++){   
				System.out.println(a[i]);    
			}   
		}     

		public  void sort(int[] array){     
			//首先确定排序的趟数;     
			int max=array[0];     
			for(int i=1;i&lt;array.length;i++){     
				if(array[i]&gt;max){     
					max=array[i];     
				}     
			}     
			int time=0;     
			//判断位数;     
			while(max&gt;0){     
				max/=10;     
				time++;     
			}     

			//建立10个队列;     
			List&lt;ArrayList&gt; queue=new ArrayList&lt;ArrayList&gt;();     
			for(int i=0;i&lt;10;i++){     
				ArrayList&lt;Integer&gt; queue1=new ArrayList&lt;&gt;();   
				queue.add(queue1);     
			}     

			//进行time 次分配和收集;     
			for(int i=0;i&lt;time;i++){     
				//分配数组元素;     
				for(intj=0;j&lt;array.length;j++){     
					//得到数字的第time+1 位数;   
					int x=array[j]%(int)Math.pow(10,i+1)/(int)Math.pow(10, i); 
					ArrayList&lt;Integer&gt;queue2=queue.get(x);   
					queue2.add(array[j]);   
					queue.set(x, queue2);   
				}    
				int count=0;//元素计数器;     
				//收集队列元素;     
				for(int k=0;k&lt;10;k++){   
					while(queue.get(k).size()&gt;0){   
						ArrayList&lt;Integer&gt; queue3=queue.get(k);   
						array[count]=queue3.get(0);     
						queue3.remove(0);   
						count++;   
					}     
				}     
			}                
		}   
	}   
</code></pre>

<h1 id="2树结构">2、树结构</h1>

<pre><code class="language-Java">	class BinaryNode&lt;T&gt; {
		BinaryNode&lt;T&gt; left;
		BinaryNode&lt;T&gt; right;
		T data;

		boolean isLeaf() {
			return left == null &amp;&amp; right == null;
		}
	}

	class Tree&lt;T extends Comparable&gt; {

		private BinaryNode&lt;T&gt; root;


		BinaryNode&lt;T&gt; insert(T data) {
			checkEmpty(data);
			root = insert(data,root);
		}


		BinaryNode&lt;T&gt; insert(T data,BinaryNode&lt;T&gt; node) {
			BinaryNode&lt;T&gt; temp = node;

	 		if(temp == null) {
	 			temp = new BinaryNode&lt;&gt;();
	 			temp.data = data;
	 		}

	 		if(data.compareTo(temp.data) &lt; 0) {
	 			temp.left = insert(data,temp.left);
	 		}else if(data.compareTo(temp.data) &gt; 0) {
	 			temp.right = insert(data,temp.right);
	 		}

	 		return temp;
		}

		void checkEmpty(T data) {
			if(null == data) {
				throw new IllegalArgument("data cannot be null");
			}
		}

		void delete(T data) {
			checkEmpty(data);

			root = delete(data,root);
		}

		BinaryNode&lt;T&gt; delete(T data,BinaryNode&lt;T&gt; node) {

			if(null == node) return node;

			if(data.compareTo(node.data) &lt; 0) {
				node.left = delete(data,node.left);
			}else if(data.compareTo(node.data) &gt;0) {
				node.right = delete(data,node.right);
			}else if(node.left != null &amp;&amp; node.right != null) {
				node.data = findMin(node.right).data;
				node.right = delete(node.data,node.right);
			}else {
				node = node.left ==null ? node.left: node.right;
			}

			return node;

		}


		BinaryNode&lt;T&gt; findMin(BinaryNode&lt;T&gt; node) {

			if(node == null) return node;

			return node = findMin(node.left);	

		}

		int height() {
			return height(root);
		}

		int height(BinaryNode&lt;T&gt; node) {
			if(node == null) return 0;

			int leftHeight = height(node.left);
			int rightHeight = height(node.right);

			if(leftHeight &gt; rightHeight) ? leftHeight + 1  ： rightHeight + 1;
		}


		int size() {return size(root);}

		int size(BinaryNode&lt;T&gt; node) {
			if(node == null) return 0;

			return size(node.left) + size(node.right) + 1;
		}

		void preOrder() {
			StringBuilder treeOrder = preOrder(root);

			if(treeOrder.length &gt; 1) {return treeOrder.toString().subString(0,treeOrder.size() -1 );}

			return treeOrder;
		}

		StringBuilder preOrder(BinaryNode&lt;T&gt; node) {
			StringBuilder treeOrder = new StringBuilder();
			if(node == null) {return treeOrder;}

			treeOrder.append(node.data)
					  .append(",")
					  .append(preOrder(node.left))
					  .append(preOrder(node.right));

			return treeOrder;
		}

		void preOrder() {
			StringBuilder treeOrder = new StringBuilder();
			Stack&lt;BinaryNode&lt;T&gt;&gt; stack = new Stack&lt;&gt;();

			stack.push(root);

			while(stack.isEmpty()) {
				BinaryNode&lt;T&gt; node = stack.pop();

				if(node == null) {
					continue;
				}

				treeOrder.append(node.data)
					  .append(",");

				if(null != node.left) {
					stack.push(node.left);
				}

				if(null != node.right) {
					stack.push(node.right);
				}


			}

			if(treeOrder.length() &gt; 1) {treeOrder.toString().subString(0,treeOrder.length() -1);}
		}


		String postOrderTraverse(){
		   StringBuffer sb=new StringBuffer();
		   //构建用于存放结点的栈
		   LinkedStack&lt;BinaryNode&lt;T&gt;&gt; stack=new LinkedStack&lt;&gt;();

		   BinaryNode&lt;T&gt; currentNode =this.root;
		   BinaryNode&lt;T&gt; prev=this.root;

		   while (currentNode!=null||!stack.isEmpty()){
		       //把左子树加入栈中,直到叶子结点为止
		       while (currentNode!=null){
		           stack.push(currentNode);
		           currentNode=currentNode.left;
		       }

		       //开始访问当前结点父结点的右孩子
		       if(!stack.isEmpty()){
		           //获取右孩子，先不弹出
		           BinaryNode&lt;T&gt; temp=stack.peek().right;
		           //先判断是否有右孩子或者右孩子是否已被访问过
		           if(temp==null||temp==prev){//没有右孩子||右孩子已被访问过
		               //如果没有右孩子或者右孩子已被访问,则弹出父结点并访问
		               currentNode=stack.pop();
		               //访问
		               sb.append(currentNode.data+",");
		               //记录已访问过的结点
		               prev=currentNode;
		               //置空当前结点
		               currentNode=null;
		           }else {
		               //有右孩子,则开始遍历右子树
		               currentNode=temp;
		           }
		       }

		   }

		   //去掉最后一个逗号
		   if(sb.length()&gt;0){
		       return sb.toString().substring(0,sb.length()-1);
		   }else {
		       return sb.toString();
		   }
		}

		String levelOrder() {

		   LinkedList&lt;BinaryNode&lt;T&gt;&gt; queue=new LinkedList&lt;&gt;();
		   StringBuffer sb=new StringBuffer();
		   BinaryNode&lt;T&gt; p=this.root;

		   while (p!=null){	
		       sb.append(p.data);
		       if(p.left!=null){
		           queue.add(p.left);
		       }

		       if (p.right!=null){
		           queue.add(p.right);
		       }
		       p=queue.poll();
		   }
		   return sb.toString();
		}

	}
</code></pre>


                <hr>


                <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">CC A-S 4.0 International License</a>.

                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/blog/MySQL-Master-Slave.html" data-toggle="tooltip" data-placement="top" title="MYSQL主从同步原理">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/blog/JVM-memory.html" data-toggle="tooltip" data-placement="top" title="JVM内存布局">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- Duoshuo Share start -->
                <style>
                    .ds-share{
                        text-align: right;
                    }
                    
                    @media only screen and (max-width: 700px) {
                        .ds-share {

                        }
                    }
                </style>

                <div class="ds-share"
                    data-thread-key="/blog/DataStrucure-Algorithm" data-title="二叉树与常用算法"
                    data-images="http://localhost:4000/img/fantasy.jpg"
                    data-content="1、常用算法


  插入排序（直接插入排序、希尔排序）
  交换排序（冒泡排序、快速排序）
  选择排序（直接选择排序、堆排序）
  归并排序
  分配... | Microdust:Azeril's blog"
                    data-url="http://localhost:4000/blog/DataStrucure-Algorithm.html">
                    <div class="ds-share-inline">
                      <ul  class="ds-share-icons-16">

                        <li data-toggle="ds-share-icons-more"><a class="ds-more" href="#">分享到：</a></li>
                        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
                        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
                        <li><a class="ds-douban" href="javascript:void(0);" data-service="douban">豆瓣</a></li>
                      </ul>
                      <div class="ds-share-icons-more">
                      </div>
                    </div>
                <hr>
                </div>
                <!-- Duoshuo Share end-->




                <!-- 多说评论框 start -->
                <div class="comment">
                    <div class="ds-thread" data-thread-key="/blog/DataStrucure-Algorithm" data-title="二叉树与常用算法" data-url="http://localhost:4000/blog/DataStrucure-Algorithm.html"></div>
                </div>
                <!-- 多说评论框 end -->
            </div>
        </div>
    </div>
</article>



<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"azeril"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!-- 多说公共JS代码 end -->



</script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>

  
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <!--
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://twitter.com/lqjacklee">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    -->

                    
                    <li>
                        <a href="https://github.com/lqjack">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <!--
                    
                    <li>
                        <a href="http://www.douban.com/people/lqjacklee">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-douban fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    

                    
                    <li>
                        <a href="https://www.facebook.com/lqjacklee">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    

                    
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/lqjacklee">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/lqjacklee">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    -->

                </ul>
                <p class="copyright text-muted">
                &copy; 2011~2018 lqjack ♪ Powered by Jekyll.
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>




<!-- Highlight.js -->
<script>
    async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js",function(){
        hljs.initHighlightingOnLoad();
    })
</script>
<link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">


</body>

</html>