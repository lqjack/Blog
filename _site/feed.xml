<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
	<channel>
		<title>Page</title>
		<description>Stay  hungry，Stay  foolish!</description>
		<link>/</link>
		<atom:link href="/" rel="self" type="application/rss+xml" />
		
			<item>
				<title>查询性能优化</title>
				<description>&lt;p&gt;1, 慢查询基础&lt;/p&gt;

&lt;p&gt;向数据库请求了不需要的数据&lt;/p&gt;

&lt;p&gt;响应时间 服务时间 + 等待时间（IO/锁）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;扫描表 通过设置db_block_multiblock_read_count可以设置一次IO能读取的数据块个数，从而有效减少全表扫描时的IO总次数，也就是通过预读机制将将要访问的数据块预先读入内存中。只有在全表扫描情况下才能使用多块读操作。


扫描索引 
范围访问 1，在唯一索引上使用了range操作符（&amp;gt;,&amp;lt;,&amp;lt;&amp;gt;,&amp;gt;=,&amp;lt;=,between）；2，在组合索引上，只使用部分列进行查询；3，对非唯一索引上的列进行的查询。
单值访问 
rowid访问（oracle) 由于rowid中记录了行存储的位置，所以这是oracle存取单行数据的最快方法。	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;扫描的数据
返回的数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MySQL使用如下三种方式应用Where条件，从好到坏
a, 索引中使用where条件过滤不匹配的记录，在存储引擎完成
b, 使用索引覆盖扫描来返回记录，直接从索引中过滤不需要的记录并返回命中的结果，在服务层完成
c, 从数据中返回数据，然后过滤不满足条件的结果，这是在MySQL服务层完成的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2, 重构查询方式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;一个复杂的查询还是多个简单查询
切分查询
分解关联查询
	优点：
		缓存效率更高
		减少锁竞争
		应用层做关联，更容易高性能和扩展
		查询本身可以提高
		可以减少冗余，应用层查询，只需要查询一次
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3, 查询基础&lt;/p&gt;

&lt;p&gt;查询流程：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;客户端发送查询到服务器
服务器查询缓存，命中直接返回
服务器进行SQL解析，预处理，优化器生成执行计划
调用存储层API执行存储计划
将结果返回给调用者
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通信协议： 半双工（服务器端发送或者客户端发送数据），一旦开始发送，另一端必须接受所有的数据&lt;/p&gt;

&lt;p&gt;查询状态&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	sleep  线程等待客户端的请求
	query  执行查询/结果返回给客户端
	locked 服务层线程等待锁
	analyzing and statstics 收集存储引擎的统计信息，生成执行计划
	copy to the tmp table [on disk] 结果复制到临时表
	sorting result 对结果进行排序
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;查询缓存&lt;/p&gt;

&lt;p&gt;查询优化处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;语法解析和预处理
查询优化器

	优化器由于错误原因导致选择执行计划	

		统计信息不准确
		执行计划的成本估算不等同与实际的执行成本
		没有考虑并发执行
		可能不是基于成本估计的


	能够处理的优化类型：

		重新定义关联表的顺序
		外连接转换为内连接
		使用等价变换规则
		优化count(), min(), max()
		预估并转换为常数表达式
		覆盖扫描索引
		子查询优化
		提前终止查询
		等值传播
		列表In的比较 ： in() log(n) ; or() : n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4, 查询优化器的限制&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;关联子查询
union限制
索引合并优化
等值传递
并行执行
哈希关联
松散索引扫描
最大值与最小值
在同一个表上查询和更新
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5，查询优化器的提示(hint)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;high_prioriy/low_prioriy
delayed
straign_join 
sql_small_result/sql_big_result
sql_buffer_result
sql_cache/sql_no_cache
sql_cal_found_rows
for update/lock in share mode
use index/force index/ignore index
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6, 优化特定查询&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;优化count() 
优化关联查询
优化子查询
优化group by/distinct
优化limit
优化union
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;7，总结&lt;/p&gt;

&lt;p&gt;尽量少做
不做
尽可能快的完成&lt;/p&gt;

</description>
				<pubDate>Sat, 30 Mar 2019 21:58:59 +0800</pubDate>
				<link>/blog/optimize-search.html</link>
				<guid isPermaLink="true">/blog/optimize-search.html</guid>
			</item>
		
			<item>
				<title>高性能索引</title>
				<description>&lt;p&gt;1, 索引类型&lt;/p&gt;

&lt;p&gt;1.1, B-Tree&lt;/p&gt;

&lt;p&gt;a, 有效规则：&lt;/p&gt;

&lt;p&gt;全值匹配
匹配最左前缀
匹配列前缀
匹配范围值
精确匹配某一列并范围另一列
只访问索引的查询&lt;/p&gt;

&lt;p&gt;b, 限制：&lt;/p&gt;

&lt;p&gt;如果不是最左索引开始，不能使用索引
不能跳过索引的列
查询中包含范围查询，右边的所有列都不能使用索引&lt;/p&gt;

&lt;p&gt;1.2, Hash&lt;/p&gt;

&lt;p&gt;a, 有效规则&lt;/p&gt;

&lt;p&gt;只有精确匹配索引的列才有效&lt;/p&gt;

&lt;p&gt;b, 限制：&lt;/p&gt;

&lt;p&gt;只包含索引值和行指针
不是按照顺序存储， 不能排序
不支持部分索引查询
只支持相等(= &amp;lt;&amp;gt; in )
速度快，哈希冲突会减慢&lt;/p&gt;

&lt;p&gt;1.3， 自适应索引&lt;/p&gt;

&lt;p&gt;索引值被频繁使用，会在内存中简历B-Tree上建立hash索引&lt;/p&gt;

&lt;p&gt;1.4 空间索引&lt;/p&gt;

&lt;p&gt;1.5 全文索引&lt;/p&gt;

&lt;p&gt;1.6 其他索引&lt;/p&gt;

&lt;p&gt;2, 优点&lt;/p&gt;

&lt;p&gt;减少服务器扫描数量
避免服务器排序和临时表
随机IO转变为顺序IO&lt;/p&gt;

&lt;p&gt;3，策略&lt;/p&gt;

&lt;p&gt;独立的列
前缀索引和索引选择性 索引部分字符，减少索引空间，提高索引效率； 索引选择性： 不重复索引值/总的记录数
多列索引&lt;/p&gt;

&lt;p&gt;多个索引做相交操作，需要包含所有相关的索引项目
多个索引操作时，耗费大量CPU，内存等资源
优化器不会将其计算到查询成本&lt;/p&gt;

&lt;p&gt;选择合适的索引顺序&lt;/p&gt;

&lt;p&gt;不考虑分组和排序，区分度较高的列放在前面是好的；where语句包含索引部分前缀列的选择性更好；与数据分布有关系&lt;/p&gt;

&lt;p&gt;聚簇索引 ： 数据存放在叶子结点，数据行跟相邻的键值紧凑的存放在一起&lt;/p&gt;

&lt;p&gt;a, 优点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;相关数据存放在一起，较少磁盘IO
访问数据更快
使用覆盖索引可以直接使用主键值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;b, 缺点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;若索引数据全部可以放在内存，聚簇索引优势不明显
插入速度依赖插入顺序
更新聚簇索引代价很高
聚簇索引可能导致全表扫描
二级索引（非聚簇索引）比想象的大，包含主键索引的列
二级索引需要两次索引查处
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;覆盖索引 包含所有查询字段的值
使用索引排序 只有索引列跟order by的子句顺序完全一致，并且排序方向是的一样的，MySQL才能使用索引排序。&lt;/p&gt;

&lt;p&gt;压缩索引
冗余与重复索引&lt;/p&gt;

&lt;p&gt;4， 索引和表的维护&lt;/p&gt;

&lt;p&gt;MyISAM表损坏通常是系统崩溃导致。
使用repaire table修复表。
执行optimize table或者导出再倒入重新整理数据，对于不支持这个草走的可以通过alter table &lt;tableName&gt; engine=&lt;engine&gt;来完成。&lt;/engine&gt;&lt;/tableName&gt;&lt;/p&gt;

</description>
				<pubDate>Sat, 30 Mar 2019 12:32:00 +0800</pubDate>
				<link>/blog/index.html</link>
				<guid isPermaLink="true">/blog/index.html</guid>
			</item>
		
			<item>
				<title>接口与内部类</title>
				<description>&lt;p&gt;1， 接口&lt;/p&gt;

&lt;p&gt;不是类，是对需求的描述&lt;/p&gt;

&lt;p&gt;回调：某个事件发生时候触发的动作&lt;/p&gt;

&lt;p&gt;2， 克隆&lt;/p&gt;

&lt;p&gt;默认时浅拷贝，没有包含克隆对象中的内部对象&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;默认的clone是否满足要求&lt;/li&gt;
  &lt;li&gt;默认的clone是否可以通过调用可变变量的clone满足需求&lt;/li&gt;
  &lt;li&gt;是否不应该使用clone&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3， 内部类&lt;/p&gt;

&lt;p&gt;内部类可以访问类定义的作用域中的数据，包括私有数据
内部类可以对同一个包中的其他类进行隐藏
定义回调函数，使用匿名类更便捷
内部类引用外部类的属性 等价于 内部类有一个外部类的引用：OutClass.this.fieldName（编译器为内部类生成一个包含外部类引用的构造器，为内部类生成外部类引用的字段）
编译器将内部类编译为用$分割外部类和内部类的普通类&lt;/p&gt;

&lt;p&gt;局部内部类（方法中定义类，然后引用类），可以访问被final修饰的局部变量&lt;/p&gt;

&lt;p&gt;匿名内部类&lt;/p&gt;

&lt;p&gt;静态内部类，取消外部类的引用指针&lt;/p&gt;

&lt;p&gt;4， 代理
运行时创建一个实现了一组特定接口的新类，回调函数为实现InvactionHandler接口的对象
所有代理类都扩展Proxy&lt;/p&gt;
</description>
				<pubDate>Mon, 18 Mar 2019 07:03:00 +0800</pubDate>
				<link>/blog/interface_and_inner_class.html</link>
				<guid isPermaLink="true">/blog/interface_and_inner_class.html</guid>
			</item>
		
			<item>
				<title>异常</title>
				<description>
</description>
				<pubDate>Mon, 18 Mar 2019 07:03:00 +0800</pubDate>
				<link>/blog/exceptions.html</link>
				<guid isPermaLink="true">/blog/exceptions.html</guid>
			</item>
		
			<item>
				<title>对象与类</title>
				<description>&lt;p&gt;1, 使用场景：
	传统的结构程序设计通过一系列过程（即算法）来完成求解。针对规模较小的，采用过程的方式比较适合；大规模的软件开发更适合面向对象的方式来解决。主要的原因是的大问题分解为不同的对象，通过对象内部的行为（内部方法实现）与其他的协作（调用其他对象的方法）来完成复杂的业务需求。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;面向对象和方式核心是类设计，类称为对象模板，通过构造器产生新的对象。封装是将数据和行为组合在对象中，并针对调用者隐藏实现细节。核心是避免直接操作对象的数据（实体域），仅通过对象的方法进行交互。达到对象的复用和可靠性。另外，通过扩展已经存在的类来添加新的对象，扩展的新类包含被继承类的数据和方法（满足可见效的前提），仅需要添加部分的数据和方法来完成。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2, 类的特性：
类是构造对象的模版，由类的构造器创建对象实例。对象的封装是将数据和行为组合在一个包中，并对使用者隐藏了数据的实现形式。对象中数据称为实体域，操作数据过程称为方法。实例之间的交换就是通过对象之间方法的调用，引起内部数据的变化。&lt;/p&gt;

&lt;p&gt;3, 对象包含三个特性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对象行为：可以调用对象的哪些方法&lt;/li&gt;
  &lt;li&gt;对象状态：方法调用时，数据如何变化&lt;/li&gt;
  &lt;li&gt;对象标示：区分行为相同，数据不同的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4, 类之间的关联关系：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;依赖：类中的方法操作类的方法&lt;/li&gt;
  &lt;li&gt;聚合：对象中包含其他对象&lt;/li&gt;
  &lt;li&gt;继承：一个类由另外一个类继承而来
      子类可以包含父类声明的方法或者属性（public,protected,package的可见性），同时子类也可以提供新方法覆盖父类中的定义。子类显示的调用父类的方法使用super+方法名。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5, 类的初始化：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;要想使用对象，需要先构造，并指定初始状态，然后调用方法。对象变量没有实际包含对象，只是引用另一个对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java局部变量使用需要赋予初始值：方法在运行时会自动创建局部变量表、操作数栈等；其中局部变量表所需的内存空间在编译期间完成分配，不同的方法的生命周期不同，局部变量会重用局部变量表中的部分位置，这个方法需要在栈帧分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。这句话就说明了局部变量在创建时就必须进行初始化以确定分配内存大小。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java堆存放所有对象的实例，几乎所有的对象实例都在这里分配内存。在hotspot虚拟机中，内存分配后，虚拟机需要将分配到的内存空间都初始化为零值。这一步操作保证了对象的实例字段在java代码中可以不赋初始值就直接使用，程序能访问到的这些字段的数据类型所对应的零值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不要在构造器中定义与实例域重名的局部变量。不要返回引用可变对象的访问器方法（需要考虑clone)。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6, final 关键字：
final修饰的实体域，构建时必须初始化；构造器之行后，不能改进行修改。大都应用基本类型，或不可变类的域，可变考虑克隆对象。
final修饰的方法，不具有虚拟特性（即不是动态绑定）。
阻止继承关系（子类不能覆盖）；如果方法没有被覆盖，并且很短，编译器就会对其进行优化-》内联&lt;/p&gt;

&lt;p&gt;7, static 关键字：
定义为static的域，每一个类中都包含一个这样的域；而每个对象对于所有的实体域都有自己的拷贝。
静态方法是一种不能向对象施加操作的方法，不具有this指针，不能在静态方法中访问实体域；但可以访问静态域。
静态工厂是静态方法的典型应用。&lt;/p&gt;

&lt;p&gt;8, 方法调用
Java程序采用按值调用，也就是方法参数传递是通过拷贝，特别是不能修改传递给它的任何参数变量的内容。&lt;/p&gt;

&lt;p&gt;重载(overloading)：方法名称相同，参数不同。
多态（）：变量可以指向父类，也可以指向子类；一个变量可以指示多种实际类型的现象，在运行时能够自动选择调用哪个方法的现象称为动态绑定（1，编译器查看对象声明的类型和方法名，查找当前类中跟调用方相同名称以及超类中属性为public的同名方法；2，从中找到与调用方参数一致的方法；3，如果方法是static,final,private修饰方法，编译器就可以确定性的知道调用的方法【静态绑定】；4，采用动态绑定调用时，虚拟机一定调用与调用方最匹配的方法（从当前类开始，往超类中查询））。&lt;/p&gt;

&lt;p&gt;9, 初始化的步骤
初始化数据域方法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;构造器&lt;/li&gt;
  &lt;li&gt;声明中指定&lt;/li&gt;
  &lt;li&gt;初始化块&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;调用构造器的步骤：数据域初始化为默认值（0，false，null），按照类生命中出现的次序，依次执行所有的初始化语句与初始化块，调用构造器。&lt;/p&gt;

&lt;p&gt;对类的静态域进行初始化可以放在静态初始化块中。在类第一次加载时候，会执行静态域的初始化。&lt;/p&gt;

&lt;p&gt;对象在使用内存资源之外，还依赖其他资源的。可以为类添加finalize，在JVM清理对象之前被调用。但是不要依赖这个方法回收资源，调用时候不确定。同时增加一次JVM标记回收的次数。可以考虑使用Runtime.addShutdownHook()。如果某个资源需要使用完毕立刻释放，需要手动完成。&lt;/p&gt;

&lt;p&gt;10 包&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用包的主要原因是确保类名唯一性。
    &lt;blockquote&gt;
      &lt;p&gt;作用域：
** public：任何类可以访问
** private：只有定义的类可以访问
** 包：同一个包中所有方法访问
** protected: 本包和所有子类&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10, 类设计技巧：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;保证数据私有化&lt;/li&gt;
  &lt;li&gt;保证数据初始化&lt;/li&gt;
  &lt;li&gt;减少类中基础数据的使用&lt;/li&gt;
  &lt;li&gt;不是所有属性都需要访问器和更改器&lt;/li&gt;
  &lt;li&gt;指责过多的类分解为多个类&lt;/li&gt;
  &lt;li&gt;类名称和方法名称要体现指责。&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Sun, 17 Mar 2019 22:44:00 +0800</pubDate>
				<link>/blog/object_and_class.html</link>
				<guid isPermaLink="true">/blog/object_and_class.html</guid>
			</item>
		
			<item>
				<title>继承</title>
				<description>&lt;p&gt;1，类型转换
唯一目的：暂时忽略对象实际类型，使用对象的全部功能。&lt;/p&gt;

&lt;p&gt;2，Object&lt;/p&gt;

&lt;p&gt;2.1， equals
检测两个对象是否相等&lt;/p&gt;

&lt;p&gt;if(this == otherObject) return true;
if(otherObject == null) return false;
if(getClass() != otherObject.getClass()) return false;
ClassName other = (ClassName)otherObject;
return filed1 == otherObject.filed &amp;amp;&amp;amp; Object.equals(field2,otherObject.field2)&lt;/p&gt;

&lt;p&gt;如果子类定义，需要调用super.equals(other)
如果是数组，使用Arrays.equals&lt;/p&gt;

&lt;p&gt;2.2 hashCode&lt;/p&gt;

&lt;p&gt;由对象导出一个整数值。如果重新定义equals方法，那么hashCode必须重新定义
同一个类中不同的属性使用 7 * a + 11 * b + 13 * c 
多个组合多个散列使用Objects.hashCode
如果存在数组类型使用，Arrays.hashCode&lt;/p&gt;

&lt;p&gt;2.3 toString
返回对象值的字符串
getClass().getName() + “[name=” + name + “, salary=” + salary + “]”;&lt;/p&gt;

&lt;p&gt;3，自动装箱&lt;/p&gt;

&lt;p&gt;自动装箱（编译器处理）规范要求boolean,byte,char &amp;lt;= 127,-128 &amp;lt; short(int) &amp;lt; int 被包装到固定的对象（即相等）&lt;/p&gt;

&lt;p&gt;4，枚举&lt;/p&gt;

&lt;p&gt;是一个类，刚好具有跟枚举种类相等的实例，使用==判断相等，所有枚举类都是Enum的子类&lt;/p&gt;

&lt;p&gt;EnumType enumType = Enum.valueOf(EnumType.class,”EnumType”)&lt;/p&gt;

&lt;p&gt;ordinal 位置从0开始&lt;/p&gt;

&lt;p&gt;5, 反射
能够分析类的能力
提供了丰富精心设计的工具包，能够动态操纵Java 代码的程序。&lt;/p&gt;

&lt;p&gt;运行时，Java为每个对象维护运行时类型标示，跟踪对象所属于的类。&lt;/p&gt;

&lt;p&gt;受限于Java访问控制，如果没有受到安全管理器的控制，就可以覆盖访问控制（setAccessible(true)）。&lt;/p&gt;

&lt;p&gt;Object newArray = Array.newInstance(componetType,length)&lt;/p&gt;

&lt;p&gt;6，异常捕获&lt;/p&gt;

&lt;p&gt;程序运行时发生错误，抛出异常。由异常处理程序处理。如果没有，程序会终止，并打印错误信息。&lt;/p&gt;

&lt;p&gt;未检查异常：应该避免发生的错误
已检查异常：&lt;/p&gt;

&lt;p&gt;7, 继承设计技巧&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将公共操作和域放在超类中&lt;/li&gt;
  &lt;li&gt;不要使用受保护的域&lt;/li&gt;
  &lt;li&gt;使用继承实现is-a&lt;/li&gt;
  &lt;li&gt;除非所有继承都有意义，否则不要使用继承&lt;/li&gt;
  &lt;li&gt;在覆盖方法时，不要改变预期的行为&lt;/li&gt;
  &lt;li&gt;使用多态，非类型信息（if (x is type of 1))&lt;/li&gt;
  &lt;li&gt;不要过多的使用反射&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Sun, 17 Mar 2019 12:00:00 +0800</pubDate>
				<link>/blog/extends.html</link>
				<guid isPermaLink="true">/blog/extends.html</guid>
			</item>
		
			<item>
				<title>同步异步、阻塞非阻塞</title>
				<description>&lt;h2 id=&quot;同步与异步&quot;&gt;同步与异步&lt;/h2&gt;
&lt;p&gt;同步/异步, 它们是消息的通知机制&lt;/p&gt;

&lt;h4 id=&quot;概念解释&quot;&gt;概念解释&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;
所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。&lt;/p&gt;

&lt;p&gt;按照这个定义，其实绝大多数函数都是同步调用（例如sin isdigit等）。
但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。
最常见的例子就是 SendMessage。
该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。
当对方处理完毕以后，该函数才把消息处理函数所返回的值返回给调用者。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;异步&lt;/strong&gt;
异步的概念和同步相对。
当一个异步过程调用发出后，调用者不会立刻得到结果。
实际处理这个调用的部件是在调用发出后，
通过状态、通知来通知调用者，或通过回调函数处理这个调用。&lt;/p&gt;

&lt;p&gt;以 Socket为例，
当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程不用等待结果，可立刻继续向下运行。
当连接真正建立起来以后，socket底层会发送一个消息通知该对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三种返回结果途径&lt;/strong&gt; 
执行部件和调用者可以通过三种途径返回结果：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;状态、&lt;/li&gt;
  &lt;li&gt;通知、&lt;/li&gt;
  &lt;li&gt;回调函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;至于回调函数，和通知没太多区别。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;举例说明&quot;&gt;举例说明&lt;/h4&gt;
&lt;p&gt;理解这两个概念，可以用去银行办理业务(可以取钱，也可以存钱)来比喻:
当到银行后,
.可以去ATM机前排队等候                                – (排队等候)就是同步等待消息
.可以去大厅拿号,等到排到我的号时，
 柜台的人会通知我轮到我去办理业务.              – (等待别人通知)就是异步等待消息.&lt;/p&gt;

&lt;p&gt;在异步消息通知机制中,
等待消息者(在这个例子中就是等待办理业务的人)往往注册一个回调机制,
在所等待的事件被触发时由触发机制(在这里是柜台的人)通过某种机制(在这里是写在小纸条上的号码)
找到等待该事件的人.&lt;/p&gt;

&lt;p&gt;在select/poll 等IO 多路复用机制中就是fd,
当消息被触发时,触发机制通过fd 找到处理该fd的处理函数.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在实际的程序中,
同步消息通知机制：就好比简单的read/write 操作,它们需要等待这两个操作成功才能返回;
               同步, 是由处理消息者自己去等待消息是否被触发;
异步消息通知机制：类似于select/poll 之类的多路复用IO 操作,
               当所关注的消息被触发时,由消息触发机制通知触发对消息的处理.
               异步, 由触发机制来通知处理消息者;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还是回到上面的例子,
轮到你办理业务, 这个就是你关注的消息,
而办理什么业务, 就是对这个消息的处理,
两者是有区别的.&lt;/p&gt;

&lt;p&gt;而在真实的IO 操作时: 所关注的消息就是     该fd是否可读写,
                     而对消息的处理是     对这个fd 进行读写.&lt;/p&gt;

&lt;p&gt;同步/异步仅仅关注的是如何通知消息,它们对如何处理消息并不关心,
好比说,银行的人仅仅通知你轮到你办理业务了,
而办理业务什么业务(存钱还是取钱)他们是不知道的.&lt;/p&gt;

&lt;p&gt;二、阻塞与非阻塞
阻塞/非阻塞, 它们是程序在等待消息(无所谓同步或者异步)时的状态.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;概念解释
A. 阻塞
阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。
有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。
对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;socket接收数据函数recv是一个阻塞调用的例子。
当socket工作在阻塞模式的时候， 如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。&lt;/p&gt;

&lt;p&gt;B. 非阻塞
非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。&lt;/p&gt;

&lt;p&gt;C. 对象的阻塞模式和阻塞函数调用
对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。&lt;/p&gt;

&lt;p&gt;阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，
在适当的时候调用阻塞函数，就可以避免阻塞。
而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;举例说明
继续上面的那个例子,
不论是排队等待，还是使用号码等待通知,
如果在这个等待的过程中,
. 等待者除了等待消息之外不能做其它的事情,那么该机制就是阻塞的,
  表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行.
. 相反,有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待,这样的状态就是非阻塞的,
  因为他(等待者)没有阻塞在这个消息通知上,而是一边做自己的事情一边等待.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三、易混淆的点
很多人也会把异步和非阻塞混淆,
因为异步操作一般都不会在真正的IO 操作处被阻塞,
比如如果用select 函数,当select 返回可读时再去read 一般都不会被阻塞
就好比当你的号码排到时一般都是在你之前已经没有人了,所以你再去柜台办理业务就不会被阻塞.
可见,同步/异步与阻塞/非阻塞是两组不同的概念,它们可以共存组合,&lt;/p&gt;

&lt;p&gt;而很多人之所以把同步和阻塞混淆,我想也是因为没有区分这两个概念,
比如阻塞的read/write 操作中,其实是把消息通知和处理消息结合在了一起,
在这里所关注的消息就是fd 是否可读/写,而处理消息则是对fd 读/写.
当我们将这个fd 设置为非阻塞的时候,read/write 操作就不会在等待消息通知这里阻塞,
如果fd 不可读/写则操作立即返回.&lt;/p&gt;

&lt;p&gt;四、同步/异步与阻塞/非阻塞的组合分析
&lt;strong&gt;__&lt;/strong&gt;&lt;em&gt;阻塞&lt;/em&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;strong&gt;__&lt;/strong&gt;&lt;em&gt;非阻塞&lt;/em&gt;&lt;em&gt;__&lt;/em&gt;
同步 | 同步阻塞              同步非阻塞
异步 | 异步阻塞              异步非阻塞&lt;/p&gt;

&lt;p&gt;同步阻塞形式:
  效率是最低的，
  拿上面的例子来说，就是你专心排队，什么别的事都不做。&lt;/p&gt;

&lt;p&gt;实际程序中
  就是未对fd 设置O_NONBLOCK 标志位的read/write 操作,&lt;/p&gt;

&lt;p&gt;异步阻塞形式:
  如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发,也就是领了一张小纸条,
  假如在这段时间里他不能离开银行做其它的事情,那么很显然,这个人被阻塞在了这个等待的操作上面;&lt;/p&gt;

&lt;p&gt;异步操作是可以被阻塞住的,只不过它不是在处理消息时阻塞,而是在等待消息被触发时被阻塞.
  比如select 函数,
  假如传入的最后一个timeout 参数为NULL,那么如果所关注的事件没有一个被触发,
  程序就会一直阻塞在这个select 调用处.&lt;/p&gt;

&lt;p&gt;同步非阻塞形式:
  实际上是效率低下的,
  想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有,
  如果把打电话和观察排队的位置看成是程序的两个操作的话,
  这个程序需要在这两种不同的行为之间来回的切换,效率可想而知是低下的;&lt;/p&gt;

&lt;p&gt;很多人会写阻塞的read/write 操作,
  但是别忘了可以对fd 设置O_NONBLOCK 标志位,这样就可以将同步操作变成非阻塞的了;&lt;/p&gt;

&lt;p&gt;异步非阻塞形式:
  效率更高,
  因为打电话是你(等待者)的事情,而通知你则是柜台(消息触发机制)的事情,
  程序没有在两种不同的操作中来回切换.&lt;/p&gt;

&lt;p&gt;比如说，这个人突然发觉自己烟瘾犯了,需要出去抽根烟,
  于是他告诉大堂经理说,排到我这个号码的时候麻烦到外面通知我一下(注册一个回调函数),
  那么他就没有被阻塞在这个等待的操作上面,自然这个就是异步+非阻塞的方式了.&lt;/p&gt;

&lt;p&gt;如果使用异步非阻塞的情况,
  比如aio_*组的操作,当发起一个aio_read 操作时,函数会马上返回不会被阻塞,
  当所关注的事件被触发时会调用之前注册的回调函数进行处理,&lt;/p&gt;
</description>
				<pubDate>Wed, 24 Feb 2016 22:44:00 +0800</pubDate>
				<link>/blog/Sync-Block.html</link>
				<guid isPermaLink="true">/blog/Sync-Block.html</guid>
			</item>
		
			<item>
				<title>线程池</title>
				<description>&lt;p&gt;1 Exectors.newCachedThreadPool(无界线程池，可以进行自动回收)
&lt;small&gt;无界队列，阻塞队列使用SynchronousQueue（每个插入操作对应一个移除操作)&lt;/small&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MAX_VALUE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
		&lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SynchronousQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;());&lt;/span&gt;  
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2 Exectors.newFixedThreadPool(固定线程池)
&lt;small&gt;corePoolSize和maximumPoolSize的大小是一样的，不想实现Keep alive，队列无界。&lt;/small&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;newFixedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
		&lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MILLISECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LinkedBlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;());&lt;/span&gt;  
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3 Exectors.newSingleThreadPool(单个线程池)&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExecutorService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;newSingleThreadExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FinalizableDelegatedExecutorService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
		&lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MILLISECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LinkedBlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;()));&lt;/span&gt;  
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;**BlockingQueue&lt;Runnable&gt;**&lt;/Runnable&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。（如果当前运行的线程小于corePoolSize，则任务根本不会存放，添加到queue中。而是开始运行）&lt;/li&gt;
  &lt;li&gt;如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。&lt;/li&gt;
  &lt;li&gt;如果无法将请求加入队列，则创建新的线程，除非创建此线程超出maximumPoolSize，在这种情况下，任务将被拒绝。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;排队有三种通用策略：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交时，通常要求无界，maximumPoolSizes以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。&lt;/li&gt;
  &lt;li&gt;无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。&lt;/li&gt;
  &lt;li&gt;有界队列。当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
例子一：使用直接提交策略，也即SynchronousQueue。
 
首先SynchronousQueue是无界的，也就是说他存数任务的能力是没有限制的，但是由于该Queue本身的特性，在某次添加元素后必须等待其他线程取走后才能继续添加。在这里不是核心线程便是新创建的线程，但是我们试想一样下，下面的场景。
&lt;/p&gt;
&lt;p&gt;我们使用一下参数构造ThreadPoolExecutor：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;new ThreadPoolExecutor(  
				2, 3, 30, TimeUnit.SECONDS,   
				new SynchronousQueue&amp;lt;Runnable&amp;gt;(),   
				new RecorderThreadFactory(&quot;CookieRecorderPool&quot;),   
				new ThreadPoolExecutor.CallerRunsPolicy());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当核心线程已经有2个正在运行.此时继续来了一个任务（A），根据前面介绍的“如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。”,所以A被添加到queue中。
又来了一个任务（B），且核心2个线程还没有忙完，OK，接下来首先尝试1中描述，但是由于使用的SynchronousQueue，所以一定无法加入进去。
此时便满足了上面提到的“如果无法将请求加入队列，则创建新的线程，除非创建此线程超出maximumPoolSize，在这种情况下，任务将被拒绝。”，所以必然会新建一个线程来运行这个任务。
暂时还可以，但是如果这三个任务都还没完成，连续来了两个任务，第一个添加入queue中，后一个呢？queue中无法插入，而线程数达到了maximumPoolSize，所以只好执行异常策略了。
所以在使用SynchronousQueue通常要求maximumPoolSize是无界的，这样就可以避免上述情况发生（如果希望限制就直接使用有界队列）。对于使用SynchronousQueue的作用jdk中写的很清楚：此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。
(如果你的任务A1，A2有内部关联，A1需要先运行，那么先提交A1，再提交A2，当使用SynchronousQueue我们可以保证，A1必定先被执行，在A1么有被执行前，A2不可能添加入queue中)&lt;/p&gt;

&lt;p&gt;例子二：使用无界队列策略，即LinkedBlockingQueue&lt;/p&gt;

&lt;p&gt;这个就拿newFixedThreadPool来说，根据前文提到的规则：
 写道
如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。
 那么当任务继续增加，会发生什么呢？
 写道&lt;/p&gt;

&lt;p&gt;如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。
 OK，此时任务变加入队列之中了，那什么时候才会添加新线程呢？&lt;/p&gt;

&lt;p&gt;写道
如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。
这里就很有意思了，可能会出现无法加入队列吗？不像SynchronousQueue那样有其自身的特点，对于无界队列来说，总是可以加入的（资源耗尽，当然另当别论）。换句说，永远也不会触发产生新的线程！corePoolSize大小的线程数会一直运行，忙完当前的，就从队列中拿任务开始运行。所以要防止任务疯长，比如任务运行的实行比较长，而添加任务的速度远远超过处理任务的时间，而且还不断增加，如果任务内存大一些，不一会儿就爆了，呵呵。&lt;/p&gt;

&lt;p&gt;可以仔细想想哈。&lt;/p&gt;

&lt;p&gt;例子三：有界队列，使用ArrayBlockingQueue。&lt;/p&gt;

&lt;p&gt;这个是最为复杂的使用，所以JDK不推荐使用也有些道理。与上面的相比，最大的特点便是可以防止资源耗尽的情况发生。&lt;/p&gt;

&lt;p&gt;举例来说，请看如下构造方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;new ThreadPoolExecutor(  
            2, 4, 30, TimeUnit.SECONDS,   
            new ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(2),   
            new RecorderThreadFactory(&quot;CookieRecorderPool&quot;),   
            new ThreadPoolExecutor.CallerRunsPolicy());  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设，所有的任务都永远无法执行完。&lt;/p&gt;

&lt;p&gt;对于首先来的A,B来说直接运行，接下来，如果来了C,D，他们会被放到queu中，如果接下来再来E,F，则增加线程运行E，F。但是如果再来任务，队列无法再接受了，线程数也到达最大的限制了，所以就会使用拒绝策略来处理。&lt;/p&gt;

&lt;p&gt;小结：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ThreadPoolExecutor的使用还是很有技巧的。&lt;/li&gt;
  &lt;li&gt;使用无界queue可能会耗尽系统资源。&lt;/li&gt;
  &lt;li&gt;使用有界queue可能不能很好的满足性能，需要调节线程数和queue大小&lt;/li&gt;
  &lt;li&gt;线程数自然也有开销，所以需要根据不同应用进行调节。&lt;/li&gt;
  &lt;li&gt;通常来说对于静态任务可以归为：&lt;/li&gt;
  &lt;li&gt;数量大，但是执行时间很短&lt;/li&gt;
  &lt;li&gt;数量小，但是执行时间较长&lt;/li&gt;
  &lt;li&gt;数量又大执行时间又长&lt;/li&gt;
  &lt;li&gt;除了以上特点外，任务间还有些内在关系&lt;/li&gt;
  &lt;li&gt;看完这篇问文章后，希望能够可以选择合适的类型了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;估算线程池大小：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目
或者 最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;依据：线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。
一个系统最快的部分是CPU，所以决定一个系统吞吐量上限的是CPU。增强CPU处理能力，可以提高系统吞吐量上限。但根据短板效应，真实的系统吞吐量并不能单纯根据CPU来计算。那要提高系统吞吐量，就需要从“系统短板”（比如网络延迟、IO）着手：
尽量提高短板操作的并行化比率，比如多线程下载技术
增强短板能力，比如用NIO替代IO&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
				<pubDate>Wed, 24 Feb 2016 22:44:00 +0800</pubDate>
				<link>/blog/Thread-Pool.html</link>
				<guid isPermaLink="true">/blog/Thread-Pool.html</guid>
			</item>
		
			<item>
				<title>分布式Session</title>
				<description>&lt;h1 id=&quot;1session生命周期&quot;&gt;1、Session生命周期&lt;/h1&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;创建&quot;&gt;创建&lt;/h2&gt;
&lt;p&gt;Session创建再服务端，当请求JSP,Servlet时候才会创建（包含SessionId)，默认情况下服务端会将JSESSIONID通过Cookie发送给客户端，一般maxAge属性为-1,表示仅对当前浏览器有效，各个浏览器窗口不共享，关闭浏览器就会失效。因此同一机器的两个浏览器窗口访问服务器时，会生成两个不同的Session。但是由浏览器窗口内的链接、脚本等打开的新窗口（也就是说不是双击桌面浏览器图标等打开的窗口）除外。这类子窗口会共享父窗口的Cookie，因此会共享一个Session。只访问HTML,图片等静态资源不会创建。&lt;/p&gt;

&lt;p&gt;注意：新开的浏览器窗口会生成新的Session，但子窗口除外。子窗口会共用父窗口的Session。例如，在链接上右击，在弹出的快捷菜单中选择”在新窗口中打开”时，子窗口便可以访问父窗口的Session。&lt;/p&gt;

&lt;p&gt;再次访问时候，会将JSESSIONID放置在请求头中发送。Session根据该Cookie值是否同一用户。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;	request.getSession(true);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若包含参数true,服务器会先从请求中查看是否包含sessionId。若找到对应的Session则直接返回，否则创建一个新的session对象。
若参数为false,若找不到sessionId对应的对象，则返回null。&lt;/p&gt;

&lt;p&gt;若用户禁用Cookie时候，不能通过服务端通过客户端保存SessionID，可以通过URL重写或者隐藏字段发送请求。可以使用以下语句是否为true,判断客户端是否启用Cookie:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;	navigator.cookieEnabled
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;销毁&quot;&gt;销毁&lt;/h2&gt;
&lt;p&gt;设置Session超时时间有以下三种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;方法体内的参数interval为秒。
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;HttpSession ses = request.getSession();
session.setMaxInactiveInterval(interval);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;web.xml里配置如下信息
    &lt;pre&gt;&lt;code class=&quot;language-XML&quot;&gt; &amp;lt;session-config&amp;gt;
     &amp;lt;session-timeout&amp;gt;时间长度（单位为分钟）&amp;lt;/session-timeout&amp;gt;
 &amp;lt;/session-config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;在tomcat/conf/server.xml中定义defaultSessionTimeOut=时间长度（分钟），默认是30分钟。
三种方式中当值为-1时，session永不失效。优先级：(1)&amp;gt;(2)&amp;gt;(3)。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;服务器会把超时的session进行清除。&lt;/li&gt;
  &lt;li&gt;调用session.invalidate()。&lt;/li&gt;
  &lt;li&gt;服务器进程被停止.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;2cookie应用&quot;&gt;2、Cookie应用&lt;/h1&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;如何使用cookie检测初访者&quot;&gt;如何使用cookie检测初访者&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;调用HttpServletRequest.getCookies()获取Cookie数组&lt;/li&gt;
  &lt;li&gt;在循环中检索指定名字的cookie是否存在以及对应的值是否正确&lt;/li&gt;
  &lt;li&gt;如果是则退出循环并设置区别标识&lt;/li&gt;
  &lt;li&gt;根据区别标识判断用户是否为初访者从而进行不同的操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用cookie检测初访者的常见错误&quot;&gt;使用cookie检测初访者的常见错误&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;不能仅仅因为cookie数组中不存在在特定的数据项就认为用户是个初访者。如果cookie数组为null，客户可能是一个初访者，也可能是由于用户将cookie删除或禁用造成的结果。&lt;/li&gt;
  &lt;li&gt;但是，如果数组非null,也不过是显示客户曾经到过你的网站或域，并不能说明他们曾经访问过你的servlet。其它servlet、JSP页面以及非Java Web应用都可以设置cookie，依据路径的设置，其中的任何cookie都有可能返回给用户的浏览器。&lt;/li&gt;
  &lt;li&gt;正确的做法是判断cookie数组是否为空且是否存在指定的Cookie对象且值正确。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用cookie属性的注意问题&quot;&gt;使用cookie属性的注意问题&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;属性是从服务器发送到浏览器的报头的一部分；但它们不属于由浏览器返回给服务器的报头。　&lt;/li&gt;
  &lt;li&gt;因此除了名称和值之外，cookie属性只适用于从服务器输出到客户端的cookie；服务器端来自于浏览器的cookie并没有设置这些属性。　&lt;/li&gt;
  &lt;li&gt;因而不要期望通过request.getCookies得到的cookie中可以使用这个属性。这意味着，你不能仅仅通过设置cookie的最大时效，发出它，在随后的输入数组中查找适当的cookie,读取它的值，修改它并将它存回Cookie，从而实现不断改变的cookie值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何使用cookie记录各个用户的访问计数&quot;&gt;如何使用cookie记录各个用户的访问计数&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;获取cookie数组中专门用于统计用户访问次数的cookie的值&lt;/li&gt;
  &lt;li&gt;将值转换成int型&lt;/li&gt;
  &lt;li&gt;将值加1并用原来的名称重新创建一个Cookie对象&lt;/li&gt;
  &lt;li&gt;重新设置最大时效&lt;/li&gt;
  &lt;li&gt;将新的cookie输出&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Wed, 24 Feb 2016 22:44:00 +0800</pubDate>
				<link>/blog/Distribute-session.html</link>
				<guid isPermaLink="true">/blog/Distribute-session.html</guid>
			</item>
		
			<item>
				<title>NIO Buffer</title>
				<description>&lt;h2 id=&quot;内部元素&quot;&gt;内部元素&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;内容： 包含基本类型，线性、有限特定基本类型序列。&lt;/li&gt;
  &lt;li&gt;容量（capacity) : Buffer对象最大能写入的大小、不变量。&lt;/li&gt;
  &lt;li&gt;最大读取位置(limit) : Buffer对象当前写入的最大位置，读取时候最大的读取位置。&lt;/li&gt;
  &lt;li&gt;当前位置(position) : 当前索引，下一个要写入和读取的位置。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;A buffer’s capacity is the number of elements it contains. The capacity of a buffer is never negative and never changes.&lt;/li&gt;
  &lt;li&gt;A buffer’s limit is the index of the first element that should not be read or written. A buffer’s limit is never negative and is never greater than its capacity.&lt;/li&gt;
  &lt;li&gt;A buffer’s position is the index of the next element to be read or written. A buffer’s position is never negative and is never greater than its limit.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;几个概念的关系&quot;&gt;几个概念的关系：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;0 &amp;lt;= mark &amp;lt;= position &amp;lt;= limit &amp;lt;= capacity&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;易混淆方法&quot;&gt;易混淆方法&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;clear: 设置limit为capacity,position为零。&lt;/li&gt;
  &lt;li&gt;flipping: 设置limit为当前位置,position为零。&lt;/li&gt;
  &lt;li&gt;rewinding: limit未设置,position为零。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;clear makes a buffer ready for a new sequence of channel-read or relative put operations: It sets the limit to the capacity and the position to zero.&lt;/li&gt;
  &lt;li&gt;flip makes a buffer ready for a new sequence of channel-write or relative get operations: It sets the limit to the current position and then sets the position to zero.&lt;/li&gt;
  &lt;li&gt;rewind makes a buffer ready for re-reading the data that it already contains: It leaves the limit unchanged and sets the position to zero.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;Buffer 抽象类，由Builder模式设计与实现。&lt;/p&gt;

</description>
				<pubDate>Wed, 24 Feb 2016 22:44:00 +0800</pubDate>
				<link>/blog/nio-buffer.html</link>
				<guid isPermaLink="true">/blog/nio-buffer.html</guid>
			</item>
		
	</channel>
</rss>
