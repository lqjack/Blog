I"<p>1, 索引类型</p>

<p>1.1, B-Tree</p>

<p>a, 有效规则：</p>

<p>全值匹配
匹配最左前缀
匹配列前缀
匹配范围值
精确匹配某一列并范围另一列
只访问索引的查询</p>

<p>b, 限制：</p>

<p>如果不是最左索引开始，不能使用索引
不能跳过索引的列
查询中包含范围查询，右边的所有列都不能使用索引</p>

<p>1.2, Hash</p>

<p>a, 有效规则</p>

<p>只有精确匹配索引的列才有效</p>

<p>b, 限制：</p>

<p>只包含索引值和行指针
不是按照顺序存储， 不能排序
不支持部分索引查询
只支持相等(= &lt;&gt; in )
速度快，哈希冲突会减慢</p>

<p>1.3， 自适应索引</p>

<p>索引值被频繁使用，会在内存中简历B-Tree上建立hash索引</p>

<p>1.4 空间索引</p>

<p>1.5 全文索引</p>

<p>1.6 其他索引</p>

<p>2, 优点</p>

<p>减少服务器扫描数量
避免服务器排序和临时表
随机IO转变为顺序IO</p>

<p>3，策略</p>

<p>独立的列
前缀索引和索引选择性 索引部分字符，减少索引空间，提高索引效率； 索引选择性： 不重复索引值/总的记录数
多列索引</p>

<p>多个索引做相交操作，需要包含所有相关的索引项目
多个索引操作时，耗费大量CPU，内存等资源
优化器不会将其计算到查询成本</p>

<p>选择合适的索引顺序</p>

<p>不考虑分组和排序，区分度较高的列放在前面是好的；where语句包含索引部分前缀列的选择性更好；与数据分布有关系</p>

<p>聚簇索引 ： 数据存放在叶子结点，数据行跟相邻的键值紧凑的存放在一起</p>

<p>a, 优点</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>相关数据存放在一起，较少磁盘IO
访问数据更快
使用覆盖索引可以直接使用主键值
</code></pre></div></div>

<p>b, 缺点</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>若索引数据全部可以放在内存，聚簇索引优势不明显
插入速度依赖插入顺序
更新聚簇索引代价很高
聚簇索引可能导致全表扫描
二级索引（非聚簇索引）比想象的大，包含主键索引的列
二级索引需要两次索引查处
</code></pre></div></div>

<p>覆盖索引 包含所有查询字段的值
使用索引排序 只有索引列跟order by的子句顺序完全一致，并且排序方向是的一样的，MySQL才能使用索引排序。</p>

<p>压缩索引
冗余与重复索引</p>

<p>4， 索引和表的维护</p>

<p>MyISAM表损坏通常是系统崩溃导致。
使用repaire table修复表。
执行optimize table或者导出再倒入重新整理数据，对于不支持这个草走的可以通过alter table <tableName> engine=<engine>来完成。</engine></tableName></p>

:ET