I"1<p>1, 处理错误</p>

<p>异常处理的任务将控制权从错误产生转移到处理这种错误处理器</p>

<ul>
  <li>用户输入错误</li>
  <li>设备错误</li>
  <li>物理限制</li>
  <li>代码错误</li>
</ul>

<p>如果不能才能正确的处理方式，可以抛出一个封装错误信息的对象，这个方法会立即退出，并不返回任何值
所有异常继承与Throwable</p>
<ul>
  <li>Error:Java运行时系统内部错误或者资源耗尽，应用程序不应该抛出此类</li>
  <li>Exception:
  ** RuntimeException 由于程序错误导致
      <em>** 错误类型转换
      **</em> 数组访问越界
      <em>** 访问空指针
      **</em> 
  ** 其他： 类似I/O异常
      <em>** 文件末尾读取文件
      **</em> 打开不存在的问题
      ***</li>
</ul>

<p>方法声明已检查异常：告诉编译器可以发生的错误。错误发生时，编译器就会寻找对应的异常处理器
一个方法必须声明所有可能抛出的异常，而未检查的异常要么不可控制（Error）,要么应该避免发生（RuntimeException)
子类在覆盖超类方法时，可以具体话异常类型</p>

<p>finally 异常发生时，释放资源（数据库等）
异常中发生异常- 》 try-with-resource，块正常或者异常退出，都会调用close方法</p>

<p>堆栈跟踪：方法调用过程的列表，包含程序执行过程中方法调用的特定位置
2, 异常处理的技巧</p>
<ul>
  <li>异常处理不能代替简单测试</li>
  <li>不要过分细化异常</li>
  <li>利用异常层次结构</li>
  <li>不要压制异常</li>
  <li>在检查错误时，苛刻要比放任更好</li>
  <li>不要羞于传递异常</li>
</ul>

<p>3, 断言
代码测试期间插入的检查语句，代码发布时，插入的检查代码自动移走
4,</p>
:ET