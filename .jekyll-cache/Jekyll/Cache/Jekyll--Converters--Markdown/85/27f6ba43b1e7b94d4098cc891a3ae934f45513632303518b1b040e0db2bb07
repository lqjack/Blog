I"îC<h1 id="1å¸¸ç”¨ç®—æ³•">1ã€å¸¸ç”¨ç®—æ³•</h1>

<ul>
  <li>æ’å…¥æ’åºï¼ˆç›´æ¥æ’å…¥æ’åºã€å¸Œå°”æ’åºï¼‰</li>
  <li>äº¤æ¢æ’åºï¼ˆå†’æ³¡æ’åºã€å¿«é€Ÿæ’åºï¼‰</li>
  <li>é€‰æ‹©æ’åºï¼ˆç›´æ¥é€‰æ‹©æ’åºã€å †æ’åºï¼‰</li>
  <li>å½’å¹¶æ’åº</li>
  <li>åˆ†é…æ’åºï¼ˆåŸºæ•°æ’åºï¼‰</li>
</ul>

<p>æ‰€éœ€è¾…åŠ©ç©ºé—´æœ€å¤šï¼šå½’å¹¶æ’åº 
æ‰€éœ€è¾…åŠ©ç©ºé—´æœ€å°‘ï¼šå †æ’åº 
å¹³å‡é€Ÿåº¦æœ€å¿«ï¼šå¿«é€Ÿæ’åº 
ä¸ç¨³å®šï¼šå¿«é€Ÿæ’åºï¼Œå¸Œå°”æ’åºï¼Œå †æ’åºã€‚</p>

<h2 id="a-ç›´æ¥æ’å…¥æ’åº">a ç›´æ¥æ’å…¥æ’åº</h2>
<p>åŸºæœ¬æ€æƒ³ï¼šåœ¨è¦æ’åºçš„ä¸€ç»„æ•°ä¸­ï¼Œå‡è®¾å‰é¢(n-1)[n&gt;=2] ä¸ªæ•°å·²ç»æ˜¯æ’å¥½é¡ºåºçš„ï¼Œç°åœ¨è¦æŠŠç¬¬n ä¸ªæ•°æ’åˆ°å‰é¢çš„æœ‰åºæ•°ä¸­ï¼Œä½¿å¾—è¿™ nä¸ªæ•° ä¹Ÿæ˜¯æ’å¥½é¡ºåºçš„ã€‚å¦‚æ­¤åå¤å¾ªç¯ï¼Œç›´åˆ°å…¨éƒ¨æ’å¥½é¡ºåºã€‚ 
æ’åºæ—¶é—´å–å†³äºè¾“å…¥å…ƒç´ çš„åˆå§‹é¡ºåºï¼Œå¯¹äºéƒ¨åˆ†æœ‰åºçš„æ’åºä½¿ç”¨æ—¶é—´è¾ƒçŸ­ã€‚</p>

<pre><code class="language-Java">void insertSort(){  
	int a[] = {45,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51};   
	for(int i = 0; i &lt; a.length; i++ ) {
		temp = a[i];
		for(int j = i-1ï¼›j&gt; 0 &amp;&amp; temp &lt; a[j];j--) {
			a[j+1] = a[j];
		}
		a[j+1] = temp;
	}
}
</code></pre>

<h2 id="b-å¸Œå°”æ’åºæœ€å°å¢é‡æ’åº">b å¸Œå°”æ’åºï¼ˆæœ€å°å¢é‡æ’åºï¼‰</h2>
<p>åŸºæœ¬æ€æƒ³ï¼šç®—æ³•å…ˆå°†è¦æ’åºçš„ä¸€ç»„æ•°æŒ‰æŸä¸ªå¢é‡ dï¼ˆn/2,nä¸ºè¦æ’åºæ•°çš„ä¸ªæ•°ï¼‰åˆ†æˆè‹¥å¹²ç»„ï¼Œæ¯ç»„ä¸­è®°å½•çš„ä¸‹æ ‡ç›¸å·®d.
å¯¹æ¯ç»„ä¸­å…¨éƒ¨å…ƒç´ è¿›è¡Œç›´æ¥æ’å…¥æ’åºï¼Œç„¶åå†ç”¨ä¸€ä¸ªè¾ƒå°çš„å¢é‡ï¼ˆd/2ï¼‰å¯¹å®ƒè¿›è¡Œåˆ†ç»„ï¼Œåœ¨æ¯ç»„ä¸­å†è¿›è¡Œç›´æ¥æ’å…¥æ’åºã€‚å½“å¢é‡å‡åˆ° 1 æ—¶ï¼Œè¿›è¡Œç›´æ¥æ’å…¥æ’åºåï¼Œæ’åºå®Œæˆã€‚ 
ä¸­ç­‰å¤§å°çš„æ•°ç»„è¿è¡Œæ—¶é—´æ˜¯å¯ä»¥æ¥å—çš„ï¼Œä»£ç é‡è¾ƒå°‘ï¼Œå¹¶ä¸”ä¸éœ€è¦é¢å¤–çš„ç©ºé—´ã€‚</p>

<pre><code class="language-Java">	shellSort(){   
		int a[]={1,54,6,3,78,34,12,45,56,100};   
		double d1=a.length;   
		int temp=0;   
		while(true){   
			d1= Math.ceil(d1/2);   
			int d=(int) d1;
			for(int x=0;x&lt; d;x++){
				for(int i=x+d;i&lt; a.length;i+=d){
					int j=i-d;
					temp=a[i];
					for(;j&gt;=0&amp;&amp;temp&lt; a[j];j-=d){
						a[j+d]=a[j];   
	              	}
	              	a[j+d]=temp;
	            }
	        }
	        if(d==1){
	        	break;
	        }
	    }
	}
</code></pre>

<h2 id="c-ç®€å•é€‰æ‹©æ’åº">c ç®€å•é€‰æ‹©æ’åº</h2>
<p>åŸºæœ¬æ€æƒ³ï¼šåœ¨è¦æ’åºçš„ä¸€ç»„æ•°ä¸­ï¼Œé€‰å‡ºæœ€å°çš„ä¸€ä¸ªæ•°ä¸ç¬¬ä¸€ä¸ªä½ç½®çš„æ•°äº¤æ¢ï¼› ç„¶ååœ¨å‰©ä¸‹çš„æ•°å½“ä¸­å†æ‰¾æœ€å°çš„ä¸ç¬¬äºŒä¸ªä½ç½®çš„æ•°äº¤æ¢ï¼Œå¦‚æ­¤å¾ªç¯åˆ°å€’æ•°ç¬¬äºŒä¸ªæ•°å’Œæœ€åä¸€ä¸ªæ•°æ¯”è¾ƒä¸ºæ­¢ã€‚ 
ç”±æœ‰åºæ•°ç»„æˆ–è€…æ•°å­—ç›¸åŒæˆ–è€…éšæœºçš„æ•°ç»„ä½¿ç”¨æ’åºæ—¶é—´ä¸€æ ·é•¿ï¼š**ç¼ºç‚¹**
æ•°æ®äº¤æ¢æœ€å°‘ï¼šæ¯æ¬¡äº¤æ¢éƒ½ä¼šæ”¹å˜ä¸¤ä¸ªæ•°ç»„çš„å€¼ï¼Œä½¿ç”¨Næ¬¡äº¤æ¢ã€‚</p>

<pre><code class="language-Java">	selectSort(){
		int a[]={1,54,6,3,78,34,12,45};
		int position=0;
		for(int i=0;i&lt; a.length;i++){
			int j=i+1;
			position=i;
			int temp=a[i];
			for(;j&lt; a.length;j++){
				if(a[j]&lt; temp){
					temp=a[j];
					position=j;
				}
			}
			a[position]=a[i];a[i]=temp;
		}
	}   
</code></pre>

<h2 id="d-å †æ’åº">d å †æ’åº</h2>
<p>åŸºæœ¬æ€æƒ³ï¼šå †æ’åºæ˜¯ä¸€ç§æ ‘å½¢é€‰æ‹©æ’åºï¼Œæ˜¯å¯¹ç›´æ¥é€‰æ‹©æ’åºçš„æœ‰æ•ˆæ”¹è¿›ã€‚ å †çš„å®šä¹‰å¦‚ä¸‹ï¼šå…·æœ‰nä¸ªå…ƒç´ çš„åºåˆ—ï¼ˆh1,h2,...,hn),å½“ä¸”ä»…å½“æ»¡è¶³ï¼ˆhi&gt;=h2i,hi&gt;=2i+1ï¼‰æˆ–ï¼ˆhi&lt;=h2i,hi&lt;=2i+1ï¼‰(i=1,2,...,n/2)æ—¶ç§°ä¹‹ä¸ºå †ã€‚åœ¨è¿™é‡Œåªè®¨è®ºæ»¡è¶³å‰è€…æ¡ä»¶çš„å †ã€‚ç”±å †çš„å®šä¹‰å¯ä»¥çœ‹å‡ºï¼Œå †é¡¶å…ƒç´ ï¼ˆå³ç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰å¿…ä¸ºæœ€å¤§é¡¹ï¼ˆå¤§é¡¶å †ï¼‰ã€‚å®Œå…¨äºŒå‰æ ‘å¯ä»¥å¾ˆç›´è§‚åœ°è¡¨ç¤ºå †çš„ç»“æ„ã€‚å †é¡¶ä¸ºæ ¹ï¼Œå…¶å®ƒä¸ºå·¦å­æ ‘ã€å³å­æ ‘ã€‚åˆå§‹æ—¶æŠŠè¦æ’åºçš„æ•°çš„åºåˆ—çœ‹ä½œæ˜¯ä¸€æ£µé¡ºåºå­˜å‚¨çš„äºŒå‰æ ‘ï¼Œè°ƒæ•´å®ƒä»¬çš„å­˜å‚¨åºï¼Œä½¿ä¹‹æˆä¸ºä¸€ä¸ªå †ï¼Œè¿™æ—¶å †çš„æ ¹èŠ‚ç‚¹çš„æ•°æœ€å¤§ã€‚ç„¶åå°†æ ¹èŠ‚ç‚¹ä¸å †çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹äº¤æ¢ã€‚ç„¶åå¯¹å‰é¢(n-1)ä¸ªæ•°é‡æ–°è°ƒæ•´ä½¿ä¹‹æˆä¸ºå †ã€‚ä¾æ­¤ç±»æ¨ï¼Œç›´åˆ°åªæœ‰ä¸¤ä¸ªèŠ‚ç‚¹çš„å †ï¼Œå¹¶å¯¹å®ƒä»¬ä½œäº¤æ¢ï¼Œæœ€åå¾—åˆ°æœ‰ nä¸ªèŠ‚ç‚¹çš„æœ‰åºåºåˆ—ã€‚ä»ç®—æ³•æè¿°æ¥çœ‹ï¼Œå †æ’åºéœ€è¦ä¸¤ä¸ªè¿‡ç¨‹ï¼Œä¸€æ˜¯å»ºç«‹å †ï¼ŒäºŒæ˜¯å †é¡¶ä¸å †çš„æœ€åä¸€ä¸ªå…ƒç´ äº¤æ¢ä½ç½®ã€‚æ‰€ä»¥å †æ’åºæœ‰ä¸¤ä¸ªå‡½æ•°ç»„æˆã€‚ä¸€æ˜¯å»ºå †çš„æ¸—é€å‡½æ•°ï¼ŒäºŒæ˜¯åå¤è°ƒç”¨æ¸—é€å‡½æ•°å®ç°æ’åºçš„å‡½æ•°ã€‚</p>

<pre><code class="language-Java">	void heapSort(int[] a){   
		int arrayLength=a.length;   
		for(int i=0;i&lt; arrayLength-1;i++){   
			buildMaxHeap(a,arrayLength-1-i);   
			swap(a,0,arrayLength-1-i);   
			System.out.println(Arrays.toString(a));   
		}   
	}   

	private  void swap(int[] data, int i, int j) {   
		int tmp=data[i];   
		data[i]=data[j];   
		data[j]=tmp;   
	}   
    
    //å¯¹data æ•°ç»„ä»0åˆ°lastIndex å»ºå¤§é¡¶å †   
	private void buildMaxHeap(int[] data, int lastIndex) {   
		//ä»lastIndex å¤„èŠ‚ç‚¹ï¼ˆæœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼‰çš„çˆ¶èŠ‚ç‚¹å¼€å§‹   
		for(int i=(lastIndex-1)/2;i&gt;=0;i--){   
			//k ä¿å­˜æ­£åœ¨åˆ¤æ–­çš„èŠ‚ç‚¹   
			int k=i;   
			//å¦‚æœå½“å‰kèŠ‚ç‚¹çš„å­èŠ‚ç‚¹å­˜åœ¨  
			while(k*2+1&lt;=lastIndex){   
				//k èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹çš„ç´¢å¼•  
				int biggerIndex=2*k+1;   
				//å¦‚æœbiggerIndex å°äºlastIndexï¼Œå³biggerIndex+1 ä»£è¡¨çš„k èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹å­˜åœ¨   
				if(biggerIndex&lt;lastIndex){  
					//è‹¥æœå³å­èŠ‚ç‚¹çš„å€¼è¾ƒå¤§   
					if(data[biggerIndex]&lt;data[biggerIndex+1]){   
						//biggerIndex æ€»æ˜¯è®°å½•è¾ƒå¤§å­èŠ‚ç‚¹çš„ç´¢å¼•   
						biggerIndex++;   
					}   
				 }   
				//å¦‚æœkèŠ‚ç‚¹çš„å€¼å°äºå…¶è¾ƒå¤§çš„å­èŠ‚ç‚¹çš„å€¼   
				if(data[k]&lt;data[biggerIndex]){   
					//äº¤æ¢ä»–ä»¬   
					swap(data,k,biggerIndex);    
					//å°†biggerIndex èµ‹äºˆkï¼Œå¼€å§‹while å¾ªç¯çš„ä¸‹ä¸€æ¬¡å¾ªç¯ï¼Œé‡æ–°ä¿è¯kèŠ‚ç‚¹çš„å€¼å¤§äºå…¶å·¦å³å­èŠ‚ç‚¹çš„å€¼   
					k=biggerIndex;   
				 }else{   
					break;   
				 }   
			}   
		}   
	}   
</code></pre>

<h2 id="e-å†’æ³¡æ’åº">e å†’æ³¡æ’åº</h2>
<p>åŸºæœ¬æ€æƒ³ï¼šåœ¨è¦æ’åºçš„ä¸€ç»„æ•°ä¸­ï¼Œå¯¹å½“å‰è¿˜æœªæ’å¥½åºçš„èŒƒå›´å†…çš„å…¨éƒ¨æ•°ï¼Œè‡ªä¸Šè€Œä¸‹å¯¹ç›¸é‚»çš„ä¸¤ä¸ªæ•°ä¾æ¬¡è¿›è¡Œæ¯”è¾ƒå’Œè°ƒæ•´ï¼Œè®©è¾ƒå¤§çš„æ•°å¾€ä¸‹æ²‰ï¼Œè¾ƒå°çš„å¾€ä¸Šå†’ã€‚å³ï¼šæ¯å½“ä¸¤ç›¸é‚»çš„æ•°æ¯”è¾ƒåå‘ç°å®ƒä»¬çš„æ’åºä¸æ’åºè¦æ±‚ç›¸åæ—¶ï¼Œå°±å°†å®ƒä»¬äº’æ¢ã€‚</p>

<pre><code class="language-Java">	bubbleSort(){  
		int a[]={49,38,65,97,76,13,64,5,4,62,99,98,54,5,35,25,53,51};   
		int temp=0;   
		for(int i=0;i&lt; a.length-1;i++){   
			for(int j=0;j&lt; a.length-1-i;j++){   
				if(a[j]&gt;a[j+1]){   
					temp=a[j];   
					a[j]=a[j+1];   
					a[j+1]=temp;   
				}   
			}
		}   
	}   
</code></pre>

<h2 id="f-å¿«é€Ÿæ’åº">f å¿«é€Ÿæ’åº</h2>
<p>åŸºæœ¬æ€æƒ³ï¼šé€‰æ‹©ä¸€ä¸ªåŸºå‡†å…ƒç´ ,é€šå¸¸é€‰æ‹©ç¬¬ä¸€ä¸ªå…ƒç´ æˆ–è€…æœ€åä¸€ä¸ªå…ƒç´ ,é€šè¿‡ä¸€è¶Ÿæ‰«æï¼Œå°†å¾…æ’åºåˆ—åˆ†æˆä¸¤éƒ¨åˆ†,ä¸€éƒ¨åˆ†æ¯”åŸºå‡†å…ƒç´ å°,ä¸€éƒ¨åˆ†å¤§äºç­‰äºåŸºå‡†å…ƒç´ ,æ­¤æ—¶åŸºå‡†å…ƒç´ åœ¨å…¶æ’å¥½åºåçš„æ­£ç¡®ä½ç½®,ç„¶åå†ç”¨åŒæ ·çš„æ–¹æ³•é€’å½’åœ°æ’åºåˆ’åˆ†çš„ä¸¤éƒ¨åˆ†ã€‚</p>

<pre><code class="language-Java">	quickSort {        
		int a[]={49,38,65,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51};   
		public quickSort(){   
			quick(a);   
			for(int i=0;i&lt; a.length;i++){   
				System.out.println(a[i]);   
			}   
		}	 

		public int getMiddle(int[] list, int low, int high) {     
			int tmp =list[low];    //æ•°ç»„çš„ç¬¬ä¸€ä¸ªä½œä¸ºä¸­è½´     
			while (low &lt; high){     
				while (low &lt; high&amp;&amp; list[high] &gt;= tmp) {     
					high--;     
				}     

				list[low] =list[high];   //æ¯”ä¸­è½´å°çš„è®°å½•ç§»åˆ°ä½ç«¯     
				while (low &lt; high&amp;&amp; list[low] &lt;= tmp) {     
					low++;     
				}     

				list[high] =list[low];   //æ¯”ä¸­è½´å¤§çš„è®°å½•ç§»åˆ°é«˜ç«¯     
			}     
			list[low] = tmp;              //ä¸­è½´è®°å½•åˆ°å°¾     
			return low;                   //è¿”å›ä¸­è½´çš„ä½ç½®     
		}    

		public void _quickSort(int[] list, int low, int high) {     
			if (low &lt; high){     
				int middle =getMiddle(list, low, high);  //å°†list æ•°ç»„è¿›è¡Œä¸€åˆ†ä¸ºäºŒ     
				_quickSort(list, low, middle - 1);       //å¯¹ä½å­—è¡¨è¿›è¡Œé€’å½’æ’åº     
				_quickSort(list,middle + 1, high);       //å¯¹é«˜å­—è¡¨è¿›è¡Œé€’å½’æ’åº     
			}     
		}   

		public void quick(int[] a2) {     
			if (a2.length &gt; 0) {    //æŸ¥çœ‹æ•°ç»„æ˜¯å¦ä¸ºç©º     
				_quickSort(a2,0, a2.length - 1);     
			}     
		}
	}    
  
</code></pre>

<h2 id="g-å½’å¹¶æ’åº">g å½’å¹¶æ’åº</h2>
<p>åŸºæœ¬æ’åºï¼šå½’å¹¶ï¼ˆMergeï¼‰æ’åºæ³•æ˜¯å°†ä¸¤ä¸ªï¼ˆæˆ–ä¸¤ä¸ªä»¥ä¸Šï¼‰æœ‰åºè¡¨åˆå¹¶æˆä¸€ä¸ªæ–°çš„æœ‰åºè¡¨ï¼Œå³æŠŠå¾…æ’åºåºåˆ—åˆ†ä¸ºè‹¥å¹²ä¸ªå­åºåˆ—ï¼Œæ¯ä¸ªå­åºåˆ—æ˜¯æœ‰åºçš„ã€‚ç„¶åå†æŠŠæœ‰åºå­åºåˆ—åˆå¹¶ä¸ºæ•´ä½“æœ‰åºåºåˆ—ã€‚
ä¿è¯ä»»æ„é•¿åº¦Nçš„æ•°ç»„æ’åºéœ€è¦çš„æ—¶é—´å’ŒNlogNæˆæ­£æ¯”ã€‚
**ç¼ºç‚¹** éœ€è¦çš„é¢å¤–ç©ºé—´å’ŒNæˆæ­£æ¯”ã€‚
sort()ä½œç”¨åœ¨äºå®‰æ’å¤šæ¬¡mergeï¼ˆï¼‰æ–¹æ³•è°ƒç”¨æ­£ç¡®é¡ºåºã€‚</p>

<pre><code class="language-Java">	mergingSort {   
		int a[]={49,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51};   
	 
		public mergingSort(){   
			sort(a,0,a.length-1);   
			for(int i=0;i&lt;a.length;i++)   
				System.out.println(a[i]);   
		}   

		public void sort(int[] data, int left, int right) {      
			if(left&lt;right){   
				//æ‰¾å‡ºä¸­é—´ç´¢å¼•   
				int center=(left+right)/2;   
				//å¯¹å·¦è¾¹æ•°ç»„è¿›è¡Œé€’å½’    
				sort(data,left,center);   
				//å¯¹å³è¾¹æ•°ç»„è¿›è¡Œé€’å½’   
				sort(data,center+1,right);   
				//åˆå¹¶   
				merge(data,left,center,right);          
			}   

		}   

		public void merge(int[] data, int left, int center, int right) {   
			int[] tmpArr=newint[data.length];   
			int mid=center+1;   
			//third è®°å½•ä¸­é—´æ•°ç»„çš„ç´¢å¼•   
			int third=left;   
			int tmp=left;   
			while(left&lt;=center&amp;&amp;mid&lt;=right){   
				//ä»ä¸¤ä¸ªæ•°ç»„ä¸­å–å‡ºæœ€å°çš„æ”¾å…¥ä¸­é—´æ•°ç»„   
				if(data[left]&lt;=data[mid]){   
					tmpArr[third++]=data[left++];   
				}else{   
					tmpArr[third++]=data[mid++];   
				}   
			}   

			//å‰©ä½™éƒ¨åˆ†ä¾æ¬¡æ”¾å…¥ä¸­é—´æ•°ç»„   
			while(mid&lt;=right){   
				tmpArr[third++]=data[mid++];   
			}   

			while(left&lt;=center){   
				tmpArr[third++]=data[left++];   
			}   

			//å°†ä¸­é—´æ•°ç»„ä¸­çš„å†…å®¹å¤åˆ¶å›åŸæ•°ç»„   
			while(tmp&lt;=right){   
				data[tmp]=tmpArr[tmp++];   
			}   
			System.out.println(Arrays.toString(data));   
		}   
	}   
</code></pre>

<h2 id="h-åŸºæ•°æ’åº">h åŸºæ•°æ’åº</h2>
<p>åŸºæœ¬æ€æƒ³ï¼šå°†æ‰€æœ‰å¾…æ¯”è¾ƒæ•°å€¼ï¼ˆæ­£æ•´æ•°ï¼‰ç»Ÿä¸€ä¸ºåŒæ ·çš„æ•°ä½é•¿åº¦ï¼Œæ•°ä½è¾ƒçŸ­çš„æ•°å‰é¢è¡¥é›¶ã€‚ç„¶åï¼Œä»æœ€ä½ä½å¼€å§‹ï¼Œä¾æ¬¡è¿›è¡Œä¸€æ¬¡æ’åºã€‚è¿™æ ·ä»æœ€ä½ä½æ’åºä¸€ç›´åˆ°æœ€é«˜ä½æ’åºå®Œæˆä»¥å,æ•°åˆ—å°±å˜æˆä¸€ä¸ªæœ‰åºåºåˆ—ã€‚ </p>

<pre><code class="language-Java">	radixSort {   
		int a[]={49,39,98,54,101,56,17,18,23,34,15,35,25,53,51};   

		public radixSort(){   
			sort(a);   
			for(inti=0;i&lt;a.length;i++){   
				System.out.println(a[i]);    
			}   
		}     

		public  void sort(int[] array){     
			//é¦–å…ˆç¡®å®šæ’åºçš„è¶Ÿæ•°;     
			int max=array[0];     
			for(int i=1;i&lt;array.length;i++){     
				if(array[i]&gt;max){     
					max=array[i];     
				}     
			}     
			int time=0;     
			//åˆ¤æ–­ä½æ•°;     
			while(max&gt;0){     
				max/=10;     
				time++;     
			}     

			//å»ºç«‹10ä¸ªé˜Ÿåˆ—;     
			List&lt;ArrayList&gt; queue=new ArrayList&lt;ArrayList&gt;();     
			for(int i=0;i&lt;10;i++){     
				ArrayList&lt;Integer&gt; queue1=new ArrayList&lt;&gt;();   
				queue.add(queue1);     
			}     

			//è¿›è¡Œtime æ¬¡åˆ†é…å’Œæ”¶é›†;     
			for(int i=0;i&lt;time;i++){     
				//åˆ†é…æ•°ç»„å…ƒç´ ;     
				for(intj=0;j&lt;array.length;j++){     
					//å¾—åˆ°æ•°å­—çš„ç¬¬time+1 ä½æ•°;   
					int x=array[j]%(int)Math.pow(10,i+1)/(int)Math.pow(10, i); 
					ArrayList&lt;Integer&gt;queue2=queue.get(x);   
					queue2.add(array[j]);   
					queue.set(x, queue2);   
				}    
				int count=0;//å…ƒç´ è®¡æ•°å™¨;     
				//æ”¶é›†é˜Ÿåˆ—å…ƒç´ ;     
				for(int k=0;k&lt;10;k++){   
					while(queue.get(k).size()&gt;0){   
						ArrayList&lt;Integer&gt; queue3=queue.get(k);   
						array[count]=queue3.get(0);     
						queue3.remove(0);   
						count++;   
					}     
				}     
			}                
		}   
	}   
</code></pre>

<h1 id="2æ ‘ç»“æ„">2ã€æ ‘ç»“æ„</h1>

<pre><code class="language-Java">	class BinaryNode&lt;T&gt; {
		BinaryNode&lt;T&gt; left;
		BinaryNode&lt;T&gt; right;
		T data;

		boolean isLeaf() {
			return left == null &amp;&amp; right == null;
		}
	}

	class Tree&lt;T extends Comparable&gt; {

		private BinaryNode&lt;T&gt; root;


		BinaryNode&lt;T&gt; insert(T data) {
			checkEmpty(data);
			root = insert(data,root);
		}


		BinaryNode&lt;T&gt; insert(T data,BinaryNode&lt;T&gt; node) {
			BinaryNode&lt;T&gt; temp = node;

	 		if(temp == null) {
	 			temp = new BinaryNode&lt;&gt;();
	 			temp.data = data;
	 		}

	 		if(data.compareTo(temp.data) &lt; 0) {
	 			temp.left = insert(data,temp.left);
	 		}else if(data.compareTo(temp.data) &gt; 0) {
	 			temp.right = insert(data,temp.right);
	 		}

	 		return temp;
		}

		void checkEmpty(T data) {
			if(null == data) {
				throw new IllegalArgument("data cannot be null");
			}
		}

		void delete(T data) {
			checkEmpty(data);

			root = delete(data,root);
		}

		BinaryNode&lt;T&gt; delete(T data,BinaryNode&lt;T&gt; node) {

			if(null == node) return node;

			if(data.compareTo(node.data) &lt; 0) {
				node.left = delete(data,node.left);
			}else if(data.compareTo(node.data) &gt;0) {
				node.right = delete(data,node.right);
			}else if(node.left != null &amp;&amp; node.right != null) {
				node.data = findMin(node.right).data;
				node.right = delete(node.data,node.right);
			}else {
				node = node.left ==null ? node.left: node.right;
			}

			return node;

		}


		BinaryNode&lt;T&gt; findMin(BinaryNode&lt;T&gt; node) {

			if(node == null) return node;

			return node = findMin(node.left);	

		}

		int height() {
			return height(root);
		}

		int height(BinaryNode&lt;T&gt; node) {
			if(node == null) return 0;

			int leftHeight = height(node.left);
			int rightHeight = height(node.right);

			if(leftHeight &gt; rightHeight) ? leftHeight + 1  ï¼š rightHeight + 1;
		}


		int size() {return size(root);}

		int size(BinaryNode&lt;T&gt; node) {
			if(node == null) return 0;

			return size(node.left) + size(node.right) + 1;
		}

		void preOrder() {
			StringBuilder treeOrder = preOrder(root);

			if(treeOrder.length &gt; 1) {return treeOrder.toString().subString(0,treeOrder.size() -1 );}

			return treeOrder;
		}

		StringBuilder preOrder(BinaryNode&lt;T&gt; node) {
			StringBuilder treeOrder = new StringBuilder();
			if(node == null) {return treeOrder;}

			treeOrder.append(node.data)
					  .append(",")
					  .append(preOrder(node.left))
					  .append(preOrder(node.right));

			return treeOrder;
		}

		void preOrder() {
			StringBuilder treeOrder = new StringBuilder();
			Stack&lt;BinaryNode&lt;T&gt;&gt; stack = new Stack&lt;&gt;();

			stack.push(root);

			while(stack.isEmpty()) {
				BinaryNode&lt;T&gt; node = stack.pop();

				if(node == null) {
					continue;
				}

				treeOrder.append(node.data)
					  .append(",");

				if(null != node.left) {
					stack.push(node.left);
				}

				if(null != node.right) {
					stack.push(node.right);
				}


			}

			if(treeOrder.length() &gt; 1) {treeOrder.toString().subString(0,treeOrder.length() -1);}
		}


		String postOrderTraverse(){
		   StringBuffer sb=new StringBuffer();
		   //æ„å»ºç”¨äºå­˜æ”¾ç»“ç‚¹çš„æ ˆ
		   LinkedStack&lt;BinaryNode&lt;T&gt;&gt; stack=new LinkedStack&lt;&gt;();

		   BinaryNode&lt;T&gt; currentNode =this.root;
		   BinaryNode&lt;T&gt; prev=this.root;

		   while (currentNode!=null||!stack.isEmpty()){
		       //æŠŠå·¦å­æ ‘åŠ å…¥æ ˆä¸­,ç›´åˆ°å¶å­ç»“ç‚¹ä¸ºæ­¢
		       while (currentNode!=null){
		           stack.push(currentNode);
		           currentNode=currentNode.left;
		       }

		       //å¼€å§‹è®¿é—®å½“å‰ç»“ç‚¹çˆ¶ç»“ç‚¹çš„å³å­©å­
		       if(!stack.isEmpty()){
		           //è·å–å³å­©å­ï¼Œå…ˆä¸å¼¹å‡º
		           BinaryNode&lt;T&gt; temp=stack.peek().right;
		           //å…ˆåˆ¤æ–­æ˜¯å¦æœ‰å³å­©å­æˆ–è€…å³å­©å­æ˜¯å¦å·²è¢«è®¿é—®è¿‡
		           if(temp==null||temp==prev){//æ²¡æœ‰å³å­©å­||å³å­©å­å·²è¢«è®¿é—®è¿‡
		               //å¦‚æœæ²¡æœ‰å³å­©å­æˆ–è€…å³å­©å­å·²è¢«è®¿é—®,åˆ™å¼¹å‡ºçˆ¶ç»“ç‚¹å¹¶è®¿é—®
		               currentNode=stack.pop();
		               //è®¿é—®
		               sb.append(currentNode.data+",");
		               //è®°å½•å·²è®¿é—®è¿‡çš„ç»“ç‚¹
		               prev=currentNode;
		               //ç½®ç©ºå½“å‰ç»“ç‚¹
		               currentNode=null;
		           }else {
		               //æœ‰å³å­©å­,åˆ™å¼€å§‹éå†å³å­æ ‘
		               currentNode=temp;
		           }
		       }

		   }

		   //å»æ‰æœ€åä¸€ä¸ªé€—å·
		   if(sb.length()&gt;0){
		       return sb.toString().substring(0,sb.length()-1);
		   }else {
		       return sb.toString();
		   }
		}

		String levelOrder() {

		   LinkedList&lt;BinaryNode&lt;T&gt;&gt; queue=new LinkedList&lt;&gt;();
		   StringBuffer sb=new StringBuffer();
		   BinaryNode&lt;T&gt; p=this.root;

		   while (p!=null){	
		       sb.append(p.data);
		       if(p.left!=null){
		           queue.add(p.left);
		       }

		       if (p.right!=null){
		           queue.add(p.right);
		       }
		       p=queue.poll();
		   }
		   return sb.toString();
		}

	}
</code></pre>
:ET