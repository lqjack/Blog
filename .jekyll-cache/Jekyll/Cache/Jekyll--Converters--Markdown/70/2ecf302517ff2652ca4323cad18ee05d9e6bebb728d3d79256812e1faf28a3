I"<h1 id="线程同步">线程同步：</h1>
<ul>
  <li>不变形</li>
  <li>枷锁</li>
  <li>线程封闭</li>
  <li>栈封闭</li>
</ul>

<h2 id="deque-blockdeque">Deque BlockDeque</h2>

<h3 id="线程窃取">线程窃取</h3>
<h1 id="线程状态">线程状态：</h1>
<ol>
  <li>新建</li>
  <li>就绪</li>
  <li>阻塞</li>
  <li>运行</li>
  <li>死亡</li>
</ol>

<h1 id="concurrenthashmapstringfuture"><code class="highlighter-rouge">ConcurrentHashMap&lt;String,Future&lt;?&gt;&gt;</code></h1>

<h1 id="可变状态是至关重要的">可变状态是至关重要的</h1>
<ul>
  <li>可变状态越少，越容易保证线程安全</li>
  <li>尽量将域声明为final</li>
  <li>不可变对象一定是线程安全的</li>
  <li>封装有助于管理复杂性</li>
  <li>锁控制可变变量</li>
  <li>保证同一个不变性条件的所有变量时，需要使用锁</li>
  <li>进行复合操作需要锁</li>
  <li>禁止随意推断不需要加锁</li>
  <li>同步策略文档化</li>
</ul>

<h1 id="同步工具类">同步工具类</h1>

<ol>
  <li>栅栏Barrier CycleBarrier Exchange</li>
</ol>
<p>闭锁用于等待事件，而栅栏用于等待线程。</p>
<ol>
  <li>信号量Semaphore</li>
</ol>
<p>控制同时访问特定资源的数量。二值信号量互斥。</p>
<ol>
  <li>闭锁CountDownLatch  FutureTask</li>
</ol>
<p>延迟到线程的进度到达终止状态，</p>

<h1 id="executorservice">ExecutorService</h1>
<p>CompletionService  Executor BlockQueue</p>

<h1 id="线程池">线程池</h1>

<ul>
  <li>newFixedThreadPool</li>
  <li>newCachedThreadPool</li>
  <li>newSchedueledThreadPool</li>
  <li>newSingleThreadPool</li>
</ul>

<p><em>shutdown 平缓关闭，等待正在执行的完成，取消将要执行的线程</em>
<em>shutdownNow 取消所有正在运行的任务，不启动在队列中的任务</em></p>

<ul>
  <li>
    <p>DelayQueue
  管理一组Delayed对象，每个对象都有一个延迟时间，只有某个元素逾期后才执行take操作，按照延迟时间排序。</p>
  </li>
  <li>
    <p>ReentrantLock
  定时
  重入
  可中断</p>
  </li>
  <li>
    <p>ReadWriteLock</p>
  </li>
  <li>
    <p>ReentrantReadWriteLock</p>
  </li>
  <li>
    <p>Condition内置条件队列</p>
  </li>
  <li>
    <p>AQS</p>
  </li>
</ul>

<pre><code class="language-Java">boolean acquire() throws InterruptedException {
	while(当前状态不允许操作) {
		if(需要阻塞获取请求) {
			如果当前线程不在队列中，则将其插入队列
			阻塞当前线程
		}
		eles
			返回失败
	}
	可能更新同步器状态
	如果线程位于队列中，将其移除队列
	返回成功
}
</code></pre>

<pre><code class="language-Java">void release() {
	更新同步器状态
	if(新的状态允许某个被阻塞的线程获取成功) {
		解除队列中一个或者多个阻塞状态
	}
}
</code></pre>

<h1 id="原子类">原子类</h1>
<ul>
  <li>AtomicInteger</li>
  <li>AtomicReference<V></V></li>
  <li>AtomicReferenceFieldUpdate&lt;Node,Node&gt;</li>
  <li>AtomicStampReference<V></V></li>
</ul>

<h1 id="内存模型">内存模型</h1>

<ol>
  <li>
    <p>重排列</p>
  </li>
  <li>
    <p>Happens-Before规则：
 程序顺序规则
 监视器规则
 voliate变量规则
 线程启动规则
 中断规则
 终结器规则
 传递性</p>
  </li>
  <li>
    <p>当缺少Happens-Before规则时候，就可能出现重排列</p>
  </li>
</ol>

<h1 id="improve">Improve</h1>

<blockquote>
  <p>queue arrayList -&gt; LinkedList&lt;&gt;</p>
</blockquote>

:ET