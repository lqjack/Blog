---
layout: post
title: 性能调优-操作系统篇
date: 2016-02-24 22:44
image: /assets/images/markdown.jpg
headerImage: false
tag:
- JVM
- Performance
star: true
category: blog
author: Jack
description: 操作系统调优
---

# 性能监控
<small>以一种非入侵的方式收集或者查看应用性能数据的活动。监控通常是一种在生产、质量评估或者开发环境中实施的带有预防性或者主动性的活动。</small>
	
## CPU使用率
* 用户态和系统态。用户态CPU使用率：执行应用程序代码的时间占总CPU时间的百分比。系统CPU使用率：执行系统调用的时间占总CPU时间百分比。
* 系统态高意味着共享资源竞争或者IO设备有大量交互。目标是：提高应用的性能可扩展性，尽量减少系统CPU使用率。
* 对于密集型应用，还要监控每分钟指令数（Instruction Per Clock）或每指令时钟周期（Cycle Per Instruction）等指标。
* 现代操作系统自带的CPU使用率监控工具只能报告CPU使用率，没有CPU指令占用CPU时钟周期百分比。当CPU在等在内存中数据，仍会报告CPU繁忙。
* 当CPU执行指令所用的操作数不在寄存器或者缓存中时候，必须等待数据从内存装入CPU寄存器，导致CPU时间浪费。
		
* 图形监控工具：`gnome-system-monitor`
* 命令行：
```Shell
	vmstat(us:用户态CPU使用率，sy:系统态CPU使用率，id：空闲率或者CPU可用率。us+sy+id=100),
	mpstat(usr,sys,wt:IO等待时间,idl)
	top
```
			
## CPU调度程序运行队列
* 运行队列包含已经准备好运行，正在等待可用CPU的轻量级进程。若数量超过系统负荷，运行队列会很长。
* 虚拟处理器的个数是系统硬件线程个数：Runtime.availableProcessors()。当运行长度队列超过虚拟处理4倍或者更多时，系统响应会很缓慢。
* 一般性原则：运行队列长度超过虚拟处理个数1倍需要关注，但不需要立即处理。若长时间高于3-4倍，需要及时处理。
* 解决办法：增加CPU分担负荷；减少处理数量。一种：从根本上减少虚拟处理器的处理数，减少运行队列中的轻量级线程；另一种：分析系统应用，改进CPU使用率。
## 内存使用率
* 除此之外，页面调度（页交换）、加锁、线程迁移中的让步和抢占式上下文切换。
* 系统在进行页面交换或者使用虚拟内存时，Java应用或者JVM表现出明显的性能问题。当应用需要内存超过物理内存就会发送页面交换，为了缓解这个问题，需要配置swap空间（在独立的磁盘分区，应用耗尽物理内存时候，系统会将部分内存放置到swap空间（通常是最少运行部分）；当被访问的部分不在内存中时，则需要从swap空间移入内存）。对于系统的响应和吞吐有较大的影响。
* JVM垃圾回收再页面交换时，性能会很差（扫描可达对象，需要大量内存，若一部分被置换出去，则需要再移入，因此会增加垃圾回收时间，导致JVM长期停滞）。
		
* vmstat(free:可用空闲内存，si:页面移入数量,so:页面移出数量)
* 锁竞争：
	* JDK1.5之前，通过CPU使用率和smtx（互斥量的自旋次数），可以监控应用中的锁竞争。
	* JDK1.5以后，HotSpot VM通过线程循环自旋尝试获得锁，若若干次忙循环后仍然没有成功，则挂起该线程，等待被唤醒再尝试获得该锁。挂起和唤醒会导致操作系统让步式切换（代价为80 000个时钟周期）。该指标可以用来衡量锁竞争。
	* mpstat(csw:上下文切换总和，icsw:抢占式上下文切换)
	* 一般原则：让步式上下文切换（csw-icsw）超过5%，表明出现锁竞争。
	* 命令行：sysstat包中pidstat -w (csw/s:让步式上下文切换) ： 报告的是每秒所有虚拟处理器让步式上下文切换数
	* 让步式上下文切换浪费时钟周期 = (pidstat -w 让步式上下文切换数)/(虚拟处理器个数)
	* sample : pidstat -w -I -p 9391 5 每5秒监控进程号9391应用。
	* 计算方式： 处理器为3.0GHz双核，每秒3500上下文切换，每个虚拟处理器上下文切换 3500/2 = 1750,耗费时钟周期 1750 * 80 000 = 140 000 000,3GHz每秒时钟周期3000 000 000,则浪费的时钟周期 4.7% = 140 000 000/ 3000 000 000（超过3%,面临竞争）
	* 工具推荐： Oracle Solaris Studio Performance Analyzer 最适合分析隔离和报告锁竞争
			
	* 抢占式上下文切换：
		1. 让步式上下文切换线程主动释放CPU，抢占式上下文切换则因分配的时间片用尽被迫放弃CPU或者其他优先级更高的线程所抢占。mpstat(icsw)
		2. taskset 创建处理器组并将应用分配给处理器组。
	* 线程迁移：
		1. 大多数操作系统CPU调度会将待运行的线程分配给上次运行的处理器，若出现处理器繁忙，调度程序会其迁移到其他的处理器运行。新的处理器没有缓存线程需要的数据以及状态，会带来性能问题。mpstat(migr)
			
## 网络IO使用率
* 分布式的Java应用的扩张和扩张收到网络带宽或者网络IO限制。当超过网络接口硬件的处理能力，将被放入系统缓冲区，导致应用延迟。
命令行：netstat；sysstat可选包，但是不提供网络使用率；nicstat(solaris移植)
```Shell
	nicstat [-hnsz] [-i interface[,...]] | [interval [count]]
		-h 帮助信息
		-n 非本地接口
		-s 概要信息
		-z 跳过0值
		-i interface 网络接口名称
		interval 报告输出的频率（秒）
		count(采样数)
		(Int:网络接口设备名；rkb/s:每秒读入的KB数；wb/s:每秒写入的KB数；rPk/s:每秒读取KB数；
			wPk/s:每秒写入的包数；rAvs:每次读取的字节数；wAvs:每次写入的的平均字节数；
			%Util:接口使用率；Sat:饱和度)
```
* 可以提供每秒发送/接收包数量（错误+ 冲突），少量冲突在以太网是正常的；大量的冲突由于网络接口卡出错、糟糕的线路或者自动协商机制。
		
* 每次读写数据量小而网络读写量大的应用会导致消耗大量的系统态CPU,产生大量系统调用。策略：减少网络读写的系统调用；使用非阻塞IO；减少处理请求和响应的线程数。误用原生的JDK NIO导致性能变差，建议使用NIO框架。
## 磁盘使用率
* 对于磁盘应用，查找性能问题，需要监控磁盘IO。
命令行：`iostat`
```shell
		sample : 
			iostat -xc 5(磁盘使用率和CPU使用率)
			iostat -xm 5(磁盘使用率和系统态CPU使用率)
```
* 为了判读读写哪个文件，使用Solaris 10和Solaris 11 Express在/usr/demo/dtrace目录下有一些DTrace脚步有助于监控磁盘活动，iosnoop.d提供详细信息（哪个用户，哪个进程，读写字节数，读写的问题件名称）
	* uid 执行磁盘操作用户ID
	* pid 进程ID
	* D R（读）或者W（写）
	* BLOCK 磁盘块
	* SIZE 数据读写字节数
	* COMM 执行磁盘访问的名称
	* PATHNAME 访问的文件名称
	* 优化策略：
		* 更快的存储设备
		* 文件扩张到多个磁盘
		* 操作系统调优可以缓存大量的文件系统数据结构
			
		* 从应用的角度，减少磁盘的活动：使用带缓冲的输入输出流；减少读写次数；集中缓冲数据结构减少磁盘交互。缓冲区减少调用操作系统的调用次数从而降低CPU使用率
		* 关于磁盘性能，检查磁盘缓冲是否开启。开启会改善严重依赖磁盘IO的应用性能，但是意外的电源故障会导致数据损坏
			
			
			
			
		
	